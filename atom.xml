<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alert Wang&#39;s blog</title>
  
  <subtitle>学习+记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-19T10:20:23.278Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alert Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux笔记</title>
    <link href="http://yoursite.com/2020/07/19/Linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/19/Linux%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-19T03:16:28.000Z</published>
    <updated>2020-07-19T10:20:23.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Linux系统的组成"><a href="#一、Linux系统的组成" class="headerlink" title="一、Linux系统的组成"></a>一、Linux系统的组成</h2><h4 id="1-内核"><a href="#1-内核" class="headerlink" title="1.内核"></a>1.内核</h4><p>​        内核是操作系统的核心，具有很多最基本的功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP/IP网络功能。</p><p>​        Linux内核的主要模块分为存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等几个部分，</p><h4 id="2-Shell"><a href="#2-Shell" class="headerlink" title="2.Shell"></a>2.Shell</h4><p>​        Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。</p><p>​        实际上，Shell是一个命令解释器，它解释由用户输入的命令并且将它们送到内核</p><p>​        另外，Shell编 程语言具有普通编程语言的很多特点，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。</p><h4 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h4><p>​        文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如xfs、ext4、ext3、ext2、msdos、vfat 和iso9660等。</p><h4 id="4-应用程序"><a href="#4-应用程序" class="headerlink" title="4.应用程序"></a>4.应用程序</h4><p>​        标准的Linux系统都有一套称为应用程序的程序集，它包括文本编辑器、编程语言、X Window、办公软件、影音软件、Internet工具和数据库等。</p><h2 id="二、安装Linux系统"><a href="#二、安装Linux系统" class="headerlink" title="二、安装Linux系统"></a>二、安装Linux系统</h2><h4 id="1-准备安装Linux系统"><a href="#1-准备安装Linux系统" class="headerlink" title="1.准备安装Linux系统"></a>1.准备安装Linux系统</h4><h4 id="2-安装Linux系统"><a href="#2-安装Linux系统" class="headerlink" title="2.安装Linux系统"></a>2.安装Linux系统</h4><h5 id="硬盘分区规划（1）"><a href="#硬盘分区规划（1）" class="headerlink" title="硬盘分区规划（1）"></a><strong>硬盘分区规划（1）</strong></h5><p>（1）最简单的分区规划</p><ul><li>swap分区：即交换分区，实现虚拟内存，建议大小是物理内存的1~2倍；</li><li>/boot分区：用来存放与Linux系统启动有关的程序，比如引导装载程序等，最少200MB；</li><li>/分区：建议大小至少在10GB以上。</li></ul><h5 id="硬盘分区规划（2）"><a href="#硬盘分区规划（2）" class="headerlink" title="硬盘分区规划（2）"></a><strong>硬盘分区规划（2）</strong></h5><p>（2）合理的分区规划</p><ul><li>swap分区：实现虚拟内存，建议大小是物理内存的1~2倍；</li><li>/boot分区：建议大小最少为200MB：</li><li>/usr分区：用来存放Linux系统中的应用程序，其相关数据较多，建议大小最少为8GB；</li><li>/var分区：用来存放Linux系统中经常变化的数据以及日志文件，建议大小最少为1GB；</li><li>/分区：Linux 系统的根目录，所有的目录都挂在这个目录下面，建议大小最少为1GB；</li><li>/home分区：存放普通用户的数据，是普通用户的宿主目录，建议大小为剩下的空间。</li></ul><h5 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a><strong>交换分区</strong></h5><ul><li>直接从物理内存读写数据要比从硬盘读写数据快的多，而物理内存是有限的，这样就使用到了虚拟内存。虚拟内存是为了满足物理内存的不足而提出的一.种策略，它是利用磁盘空间虚拟出的一-块逻辑内存，用作虚拟内存的磁盘空间被称为交换分区（swap分区）。</li><li>内核会将暂时不用的内存块信息写到交换分区，这样-来，物理内存得到了释放，这块内存就可以用于其它用途，当需要用到原始的内容时，这些信息会被重新从交换分区读入物理内存。</li><li>Linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</li></ul><h5 id="分区命名方案"><a href="#分区命名方案" class="headerlink" title="分区命名方案"></a><strong>分区命名方案</strong></h5><ul><li>Linux系统使用字母和数字的组合来指代硬盘分区，使用一种更加灵活的分区命名方案，该命名方案是基于文件的，文件名的格式为/dev/xxyN（比如/dev/sda1分区）。<ul><li>/dev：这是Linux系统中所有设备文件所在的目录名。因为分区位于硬盘上，而硬盘是设备，所以这些文件代表了在/dev_上所有可能的分区；</li><li>XX：分区名的前两个字母表示分区所在设备的类型，通常是hd（IDE硬盘）或sd（SCSI硬盘）。</li><li>y: 这个字母表示分区所在的设备。例如，/dev/hda（第1个IDE硬盘）或/dev/sdb（第2个SCSI硬盘）；</li><li>N：最后的数字N代表分区。前4个分区（主分区或扩展分区）用数字1~4表示，逻辑驱动器从5开始。例如，<br>/dev/hda3是第1个IDE硬盘上的第3个主分区或扩展分区；<br>/dev/sdb6是第2个SCSI硬盘上的第2个逻辑驱动器。</li></ul></li></ul><h4 id="3-注销、关闭和重启Linux系统"><a href="#3-注销、关闭和重启Linux系统" class="headerlink" title="3.注销、关闭和重启Linux系统"></a>3.注销、关闭和重启Linux系统</h4><h4 id="4-FirewallD防火墙"><a href="#4-FirewallD防火墙" class="headerlink" title="4.FirewallD防火墙"></a>4.FirewallD防火墙</h4><h2 id="三、字符界面操作基础"><a href="#三、字符界面操作基础" class="headerlink" title="三、字符界面操作基础"></a>三、字符界面操作基础</h2><h4 id="1-字符界面简介"><a href="#1-字符界面简介" class="headerlink" title="1.字符界面简介"></a>1.字符界面简介</h4><h5 id="进入Linux字符界面方式"><a href="#进入Linux字符界面方式" class="headerlink" title="进入Linux字符界面方式"></a><strong>进入Linux字符界面方式</strong></h5><ul><li>要进入Linux系统的字符界面可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入。</li></ul><h5 id="1、Linux字符界面"><a href="#1、Linux字符界面" class="headerlink" title="1、Linux字符界面"></a><strong>1、Linux字符界面</strong></h5><ul><li><p>安装Linux系统之后，系统启动默认进入的是图形化界面，可以通过使用以下命令修改为进入字符界面，所做改变在系统重新引导之后即可生效。<br><code>[root@rhel ~]#systemctl get-default</code> </p><p><code>graphical.target</code><br>//查看计算机系统启动后要进入的默认目标，graphical.target表示图形化界面<br><code>[root@rhel ~]#systemctl set-default multi-user.target</code><br>//将multi-user.target目标设置为启动计算机系统后要进入的默认目标，multi-user.target表示字符界面</p></li></ul><h5 id="2、字符界面登录提示"><a href="#2、字符界面登录提示" class="headerlink" title="2、字符界面登录提示"></a><strong>2、字符界面登录提示</strong></h5><ul><li>Linux系统用户登录分两步：第一步输入用户的用户名，系统根据该用户名识别用户；第二步输入用户的口令。当用户正确地输入用户名和口令后，就能合法地进入系统，这时就可以对系统进行各种操作了，注意：<br>超级用户root登录后提示符是”#”，而其他用户登录后提示符是”$”</li></ul><h5 id="3、图形界面下的终端"><a href="#3、图形界面下的终端" class="headerlink" title="3、图形界面下的终端"></a><strong>3、图形界面下的终端</strong></h5><h5 id="4、虚拟控制台"><a href="#4、虚拟控制台" class="headerlink" title="4、虚拟控制台"></a><strong>4、虚拟控制台</strong></h5><ul><li>Linux系统可以同时接受多个用户同时登录，还允许用户进行多次登录，这是因为Linux系统提供了虚拟控制台的访问方式。</li><li>在字符界面下，虚拟控制台的选择可以通过按下[Alt]键和一个功能键来实现，通常使用F1~F6键。比如用户登录后，按下[Alt+F2]键，用户可以看到“login：”提示符，说明用户进入了第二个虚拟控制台。然后只需按[Alt+F1]组合键，就可以回到第-一个虚拟控制台。</li><li>如果用户在图形界面下，那么可以使用[Ctrl+ Alt+F2]~[Ctrl+ Alt+F6]组合键切换字符虚拟控制台，使用[Ctrl+Alt+F1]可以切换到图形界面。</li></ul><h5 id="5、关闭和重启Linux系统"><a href="#5、关闭和重启Linux系统" class="headerlink" title="5、关闭和重启Linux系统"></a><strong>5、关闭和重启Linux系统</strong></h5><ul><li>在Linux系统中常用的关闭/重启系统的命令有shutdown、halt、reboot，每个命令的内部_工作过程是不同的。<ul><li><strong>shutdown命令</strong><br>shutdown命令可以安全地关闭或重启Linux系统。<br>命令语法：<br>shutdown[选项][时间][警告信息]<br>[例3.1]立即关闭计算机系统。<br><code>[root@rhel ~]#shutdown -h now</code><br>[例3.2]定时45分钟 后关闭计算机系统。<br><code>[root@rhel ~]#shutdown -h +45</code><br>[例3.3]立即重新启动计算机系统，并发出警告信息<br><code>[root@rhel ~]#shutdown -r now &quot;system will be reboot now.&quot;</code><br>[例3.4]定时在1 点38分重新启动计算机系统<br><code>[root@rhel ~]#shutdown -r 01:38</code></li><li><strong>halt命 令</strong><br>使用halt命令就是调用“shutdown-h”命令执行关机任务。<br>命令语法：halt[选项]<br>[例3.5]使用halt命 令关闭系统。<br><code>[root@rhel ~]# halt</code></li><li><strong>reboot命令</strong><br>reboot命令的工作过程与halt相似，不过reboot是引发计算机重启，而halt是引发计算机关闭。它的选项与halt相似。<br>[例3.6]使用reboot命 令重启计算机系统。<br><code>[root@rhel ~]# reboot</code></li></ul></li></ul><h5 id="6、目标"><a href="#6、目标" class="headerlink" title="6、目标"></a><strong>6、目标</strong></h5><ul><li>在RHEL7之前的版本，使用运行级别代表特定的操作模式。运行级别被定义为七个级别，用数字0到6表示，每个运行级别可以启动特定的一些服务。RHEL 7使用目标（target）替换运行级别。目标使用目标单元文件描述，目标单位文件扩展名是.target，目标单元文件的唯一目标，是将其他systemd单元文件通过一连串的依赖关系组织在一起。比如graphical.target单元，用于启动一个图形会话，systemd会启动像GNOME显示管理（gdm.service）、帐号服务（axxounts-daemon）这样的服务，并且会激活multi-user.target单元。相似的multi-user.target单元，会启动必不可少的NetworkManager service、dbus service服务，并激活basic.target单 元。</li><li>每一个目标都有名字和独特的功能，并且能够同时启用多个。一些目标继承其他目标的服务，并启动新服务。<br>systemd提供了一些模仿SystemVinit启动级别的目标，仍可以使用旧的telinit启动级别命令切换。</li><li>预定义目标和运行级别对应关系</li></ul><table><thead><tr><th>运行级别</th><th>目标</th><th>目标的链接文件</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>poweroff.target</td><td>runlevel0.target</td><td>关闭系统</td></tr><tr><td>1</td><td>rescue.target</td><td>runlevel1.target</td><td>进入救援模式</td></tr><tr><td>2</td><td>multi-user.target</td><td>runlevel2.target</td><td>进入非图形界面的多用户方式</td></tr><tr><td>3</td><td>multi-user.target</td><td>runlevel3.target</td><td>进入非图形界面的多用户方式</td></tr><tr><td>4</td><td>multi-user.target</td><td>runlevel4.target</td><td>进入非图形界面的多用户方式</td></tr><tr><td>5</td><td>graphical.target</td><td>runlevel5.target</td><td>进入图形界面的多用户方式</td></tr><tr><td>6</td><td>reboot.target</td><td>runlevel6.target</td><td>重启系统</td></tr></tbody></table><h4 id="2-在Linux系统下获取帮助"><a href="#2-在Linux系统下获取帮助" class="headerlink" title="2.在Linux系统下获取帮助"></a>2.在Linux系统下获取帮助</h4><ul><li><h5 id="使用man手册页"><a href="#使用man手册页" class="headerlink" title="使用man手册页"></a><strong>使用man手册页</strong></h5><ul><li>一般情况下，Linux系统中所有的资源都会随操作系统一起发行，包括内核源代码。而在线手册是操作系统所有资源的一本很好的使用手册。有不懂的命令时可以用man查看这个命令，写程序时有不会用的函数可以用man查看这个函数，有不懂的文件时也可以用man查看文件。</li><li>一般情况下man手册页的资源主要位于/usr/share/man目录下。</li></ul></li><li><p>man手册内/可以用于查询</p></li><li><h5 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a><strong>man命令</strong></h5><p>man命令格式化并显示在线的手册页。通常使用者只要在命令man后，输入想要获取的命令的名称，man就会列出一份完整的说明，其内容包括命令语法、各选项的意义以及相关命令等。<br>命令语法：man[选项][名称]</p></li><li><h5 id="man手册页类型"><a href="#man手册页类型" class="headerlink" title="man手册页类型"></a><strong>man手册页类型</strong></h5></li></ul><table><thead><tr><th align="center">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">用户命令</td></tr><tr><td align="center">2</td><td align="left">系统调用</td></tr><tr><td align="center">3</td><td align="left">C语言函数库</td></tr><tr><td align="center">4</td><td align="left">设备和特殊文件</td></tr><tr><td align="center">5</td><td align="left">文件格式和约定</td></tr><tr><td align="center">6</td><td align="left">游戏程序</td></tr><tr><td align="center">7</td><td align="left">杂记</td></tr><tr><td align="center">8</td><td align="left">系统管理工具</td></tr><tr><td align="center">9</td><td align="left">Linux内核API（内核调用）</td></tr></tbody></table><ul><li><h5 id="使用–help选项获取帮助"><a href="#使用–help选项获取帮助" class="headerlink" title="使用–help选项获取帮助"></a><strong>使用–help选项获取帮助</strong></h5><p>使用–help选项可以显示命令的使用方法以及命令选项的含义。只要在所需要显示的命令后面输入“–help”选项，然后就可以看到所查命令的帮助内容了。<br>命令语法：<br>[命令]–help.<br>[例3.9]查看mkdir命令的帮助信息。<br><code>[root@rhel ~]# mkdir --help</code></p></li></ul><h4 id="3-Shell基础"><a href="#3-Shell基础" class="headerlink" title="3.Shell基础"></a>3.Shell基础</h4><ul><li><p>Shell简介</p><ul><li>在AT&amp;T工作的Dennis Ritchie 和Ken Thompson两人在设计Unix操作系统的时候，想要为用户创建一种与Unix系统交流的方法。那时的操作系统带有命令解释器。命令解释器接受用户的命令，然后解释它们，因而计算机可以使用这些命令。</li><li>Ritchie和Thompson想要提供比当时的命令解释器具备更优异功能的工具。这导致了Bourne Shell（通称为sh）的开发，由S.R.Bourne创建。自从Bourne Shell出现以后，其它类型Shell也被一一开发，比如C Shell（csh）和Korn Shell（ksh）。</li><li>Shell接收用户命令，然后调用相应的应用程序，同时它还是一种程序设计语言，是系统管理维护时的重要工具。作为命令语言，它交互式的解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令。作为程序设计语言，它可以定义各种变量和参数，并提供了许多在高级语言中才具有的控制结构（循环和分支）。</li><li>Shell命令重新初始化用户的登录会话。当给出该命令时，就会重新设置进程的控制终端的端口特征，并取消对端口的所有访问。然后Shell命令为用户把进程凭证和环境重新设置为缺省值，并执行用户的初始程序。根据调用进程的登录用户标识建立所有的凭证和环境。</li><li>目前流行的Shell有sh、csh、ksh、tcsh 和bash等。大部分Linux系统的默认Shell类型为bash。</li></ul></li><li><p>bash简介</p><ul><li>bash（Bourne Again Shell）最早是在1987年由布莱恩.福克斯开发的一个为GNU计划编写的Unix Shell。bash目前是大多数Linux系统默认的Shell，它还能运行于大多数Unix风格的操作系统上。</li><li>bash的命令语法是Bourne shell命令语法的超集。数量庞大的Bourne shell脚本大多不经过修改就可以在bash中执行，只有那些引用了Bourne特殊变量或使用了Bourne内置命令的脚本才需要修改。bash的命令语法很多来自ksh和csh，比如命令行编辑、命令历史、目录栈、$RANDOM变量、$PPID变量以及POSIX命令置换语法。</li></ul></li><li><p>bash命令</p><ul><li>Linux系统的标准提示符包括了用户登录名、登录的主机名、当前所在的工作目录路径和提示符号。<br>以普通用户zhangsan登录名为rhel的主机，他的工作目录是/home/zhangsan，如下所示。<br><code>[zhangsan@rhel ~]$</code><br>以root用户登录系统的提示符如下所示。<br><code>[root@rhel ~]#</code></li></ul></li><li><p>Shell命令一般格 式</p><ul><li>要运行命令的话，只需要在提示符后敲进命令，然后再按“回车”键。<br>命令语法：<br>[Shell命令][选项][参数]</li><li>所有选项在该命令的man手册页中都有详细的介绍，而参数则由用户提供。选项决定命令如何工作，而参数则用于确定命令作用的目标。</li><li>选项有短命令行选项和长命令选项两种。</li></ul></li><li><p>Linux系统命令分类</p><ul><li>bash内置的命令<br>如果是bash内置的命令，则由bash负责回应。</li><li>应用程序<br>如果是应用程序，那么Shell会找出该应用程序，然后将控制权交给内核，由内核执行该应用程序，执行完之后，再将控制权交回给Shell。</li></ul></li></ul><h4 id="4-使用bash"><a href="#4-使用bash" class="headerlink" title="4.使用bash"></a>4.使用bash</h4><h5 id="1、常用控制组合键"><a href="#1、常用控制组合键" class="headerlink" title="1、常用控制组合键"></a><strong>1、常用控制组合键</strong></h5><table><thead><tr><th>控制组合键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+l</td><td>清屏</td></tr><tr><td>Ctrl+o</td><td>执行当前命令，并选择上一条命令</td></tr><tr><td>Ctrl+s</td><td>阻止屏幕输出</td></tr><tr><td>Ctrl+q</td><td>允许屏幕输出</td></tr><tr><td>Ctrl+c</td><td>终止命令</td></tr><tr><td>Ctrl+z</td><td>挂起命令</td></tr><tr><td>Ctrl+m</td><td>回车</td></tr><tr><td>Ctrl+d</td><td>输入结束，即EOF的意思，或者注销Linux系统</td></tr></tbody></table><h5 id="2、光标操作"><a href="#2、光标操作" class="headerlink" title="2、光标操作"></a><strong>2、光标操作</strong></h5><table><thead><tr><th>组合键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+a</td><td>移动光标到命令行首</td></tr><tr><td>Ctrl+e</td><td>移动光标到命令行尾</td></tr><tr><td>Ctrl+f</td><td>按字符前移（向右）</td></tr><tr><td>Ctrl+b</td><td>按字符后移（向左）</td></tr><tr><td>Ctrl+xx</td><td>在命令行首和光标之间移动</td></tr><tr><td>Ctrl+u</td><td>删除从光标到命令行首的部分</td></tr><tr><td>Ctrl+k</td><td>删除从光标到命令行尾的部分</td></tr><tr><td>Ctrl+w</td><td>删除从光标到当前单词开头的部分</td></tr><tr><td>Ctrl+d</td><td>删除光标处的字符</td></tr><tr><td>Ctrl+h</td><td>删除光标前的一个字符</td></tr><tr><td>Ctrl+y</td><td>插入最近删除的单词</td></tr><tr><td>Ctrl+t</td><td>交换光标处字符和光标前面的字符</td></tr><tr><td>Alt+f</td><td>按单词前移（向右）</td></tr><tr><td>Alt+b</td><td>按单词后移（向左）</td></tr><tr><td>Alt+d</td><td>从光标处删除至单词尾</td></tr><tr><td>Alt+c</td><td>从光标处更改单词为首字母大写</td></tr><tr><td>Alt+u</td><td>从光标处更改单词为全部大写</td></tr><tr><td>Alt+l</td><td>从光标处更改单词为全部小写</td></tr><tr><td>Alt+t</td><td>交换光标处单词和光标前面的单词</td></tr><tr><td>Alt+Backspace</td><td>与Ctrl+w功能类似，分隔符有些差别</td></tr></tbody></table><h5 id="3、特殊字符"><a href="#3、特殊字符" class="headerlink" title="3、特殊字符"></a><strong>3、特殊字符</strong></h5><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>~</td><td>用户主目录</td></tr><tr><td>`</td><td>反引号，用来命令替代</td></tr><tr><td>#</td><td>注释</td></tr><tr><td>$</td><td>变量取值</td></tr><tr><td>&amp;</td><td>后台进程工作</td></tr><tr><td>(</td><td>子Shell开始</td></tr><tr><td>)</td><td>子Shell结束</td></tr><tr><td>\</td><td>使命令持续到下一行</td></tr><tr><td>|</td><td>管道</td></tr><tr><td>&lt;</td><td>输入重定向</td></tr><tr><td>&gt;</td><td>输出重定向</td></tr><tr><td>&gt;&gt;</td><td>追加重定向</td></tr><tr><td>‘</td><td>单引号</td></tr><tr><td>“</td><td>双引号</td></tr><tr><td>/</td><td>路径分割符</td></tr><tr><td>;</td><td>命令分隔符</td></tr></tbody></table><h5 id="4、通配符"><a href="#4、通配符" class="headerlink" title="4、通配符"></a><strong>4、通配符</strong></h5><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>？</td><td>代表任何单一字符</td></tr><tr><td>*</td><td>代表任何字符</td></tr><tr><td>[字符组合]</td><td>在中括号中的字符都符合，比如[a~z]代表所有的小写字母</td></tr><tr><td>[!字符组合]</td><td>不在中括号中的字符都符合，比如[!0-9]代表非数字的都符合</td></tr></tbody></table><h4 id="5-Shell实用功能"><a href="#5-Shell实用功能" class="headerlink" title="5.Shell实用功能"></a>5.Shell实用功能</h4><h5 id="1、命令行自动补全"><a href="#1、命令行自动补全" class="headerlink" title="1、命令行自动补全"></a><strong>1、命令行自动补全</strong></h5><ul><li><p>在Linux系统中，有太多的命令和文件名称需要记忆，使用命令行补全功能可以快速的写出文件名和命令名。<br>如果需要快速地从当前所在的目录跳转到<br>/usr/src/kernels/目录，可以执行以下操作。<br><code>[root@rhel ~]# cd /u&lt;Tab&gt;/sr&lt;Tab&gt;/k&lt;Tab&gt;</code></p><p><Tab>是按”Tab”键的意思，使用”Tab”键也称为命令行自动补全，这在平常应用中是不可缺少的</p></li></ul><h5 id="2、命令历史记录"><a href="#2、命令历史记录" class="headerlink" title="2、命令历史记录"></a><strong>2、命令历史记录</strong></h5><ul><li>在操作Linux系统的时候，每一个操作的命令都会记录到命令历史中，在以后可以通过命令历史查看和使用以前操作的命令。</li><li>bash启动的时候会读取~/.bash_history文件，并将其载入到内存中，$HISTFILE变量就用于设置~/.bash__history文件，bash退出时也会把内存中的历史记录回写到~/.bash_history文 件中。</li><li>使用history命令可以查看命令历史记录，每一条命令前面都会有一个序列号标示。<br>命令语法：history[选项]</li><li>Ctrl+R 使用历史记录中的命令</li></ul><h5 id="3、使用命令历史"><a href="#3、使用命令历史" class="headerlink" title="3、使用命令历史"></a><strong>3、使用命令历史</strong></h5><table><thead><tr><th>举例</th><th>描述</th></tr></thead><tbody><tr><td>!!</td><td>运行上一个命令</td></tr><tr><td>!6</td><td>运行第6个命合</td></tr><tr><td>!8/test</td><td>运行第8个命令并在命令后面加上/test</td></tr><tr><td>!?CF?</td><td>运行上一个包含CF字符串的命令</td></tr><tr><td>!ls</td><td>运行上一个Is命令（或以ls开头的历史命令）</td></tr><tr><td>!ls:s/CF/G</td><td>运行上一个Is命令，其中把CF替换成G</td></tr><tr><td>fc</td><td>编辑并运行上一个历史命令</td></tr><tr><td>fc 6</td><td>编辑并运行第6条历史命令</td></tr><tr><td>^boot^root^</td><td>快速替换。将最后一个命合中的boot替换为root后运行</td></tr><tr><td>!-5</td><td>运行倒数第5个命令</td></tr><tr><td>!$</td><td>运行前一个命令最后的参数</td></tr></tbody></table><p>[例3.11]使用命令历史记录功能键。<br><code>[root@rhel ~]# mkdir/root/aaa</code><br>//创建目录/root/aaa<br><code>[root@rhel ~]# cd !$</code><br><code>cd/root/aaa</code><br>//!$是指重复前一个命令最后的参数，参数是/root/aaa<br><code>[root@rhel aaa]# pwd</code><br><code>/root/aaa</code><br>//显示用户当前目录是/root/aaa</p><h5 id="4、搜索历史命令"><a href="#4、搜索历史命令" class="headerlink" title="4、搜索历史命令"></a><strong>4、搜索历史命令</strong></h5><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>↑</td><td>查看上一个命令</td></tr><tr><td>↓</td><td>查看下一个命令</td></tr><tr><td>Ctrl+p</td><td>查看历史列表中的上一个命令</td></tr><tr><td>Ctrl+n</td><td>查看历史列表中的下一个命令</td></tr><tr><td>Ctrl+r</td><td>向上搜索历史列表</td></tr><tr><td>Alt+p</td><td>向上搜索历史列表</td></tr><tr><td>Alt+&gt;</td><td>移动到历史列表末尾</td></tr></tbody></table><h5 id="5、命令排列"><a href="#5、命令排列" class="headerlink" title="5、命令排列"></a><strong>5、命令排列</strong></h5><ul><li><p>如果希望一次执行多个命令，Shell允许在不同的命令之间，放上特殊的排列字符。</p><ul><li><p>1.使用”;”<br>使用”;”命令时先执行命令1，不管命令1是否出错，接下来就执行命2。<br>命令语法：命令1;命令2</p></li><li><p>2.使用”&amp;&amp;”<br>使用”&amp;&amp;”命令时只有当命令1正确运行完毕后，才能执行命令2。<br>命令语法：命令1&amp;&amp;命令2</p></li></ul></li></ul><h5 id="6、命令替换"><a href="#6、命令替换" class="headerlink" title="6、命令替换"></a><strong>6、命令替换</strong></h5><ul><li>在Linux系统中，Shell命 令的参数可以由另外一个命令的结果来替代，这种称之为命令替换。<br>1.使用”$（）”<br>命令语法：命令1 $（命令2）<br>2.使用”`“<br>命令语法：命令1`命令2`</li></ul><h5 id="7、命令别名"><a href="#7、命令别名" class="headerlink" title="7、命令别名"></a><strong>7、命令别名</strong></h5><ul><li>在需要执行某-一个非常长的命令时，所有的命令以及命令的选项、参数都要一一输入，很枯燥也容易出现错误。可以为常用命令定义快捷方式，这些快捷方式可以用比较简单的命令别名来定义。<ul><li>1.创建别名.<br>使用alias命令可以为命令定义别名。如果命令中有空格的话，就需要使用双引号（比如在命令与选项之间就有空格）<br>命令语法：alias[别名]=[需要定义别名的命令]</li><li>2.取消别名<br>当用户需要取消别名的定义时，可以使用unalias命令。<br>命令语法：unalias[别名]</li></ul></li></ul><h5 id="8、管道"><a href="#8、管道" class="headerlink" title="8、管道"></a><strong>8、管道</strong></h5><ul><li>Linux系统的理念是汇集许多小程序，每个程序都有特殊的专长。复杂的任务不是由大型软件完成，而是运用Shell的机制，组合许多小程序共同完成。管道就在其中发挥着重要的作用，它可以将某个命令的输出信息当作某个命令的输入，由管道符号“|”来标识。<br>命令语法：<br>[命令1]|[命令2]|[命令3]<ul><li>[例3.22]<br>使用简单的管道。<br><code>[root@rhel ~]#Is/etc|more</code><br>abr<br>tacpi<br>adjtime<br>akonadi<br>–More–<br>//命令|s/etc显示/etc目录的内容，命令more是分页显示内容</li><li>[例3.23]<br>使用复杂的管道。<br><code>[root@PC-LINUX ~]#rpm -qa|grep a|more</code><br>//命令rpm-qa显示已经安装在系统上的RPM包，命令grepa是过滤软件包，命令more是分页显示这些信息</li></ul></li></ul><h4 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6.重定向"></a>6.重定向</h4><ul><li>希望将命令的输出结果保存到文件中，或者以文件内容作为命令的参数，这时就需要用到重定向。重定向不使用系统的标准输入端口、标准输出端口或是标准错误端口，而是进行重新的指定。</li><li>重定向有四种方式：输出重定向、输入重定向、错误重定向以及同时实现输出和错误的重定向。</li></ul><h5 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a><strong>输出重定向</strong></h5><ul><li>输出重定向，即将某一命令执行的输出保存到文件中，如果已经存在相同的文件，那么覆盖源文件中的内容。命令语法：<br>[命令]&gt;[文件]<ul><li>[例3.24]使用输出重定向将/boot目录的内容保存到/root/abc文件中。<br><code>[root@rhel ~]#ls/boot &gt;/root/abc</code><br>[例3.25]使用echo命令和输出重定向创建/root/mm文件，文件内容是hello。<br><code>[root@rhel ~]#echo Hello &gt;/root/mm</code><br><code>[root@rhel ~]#cat/root/mm</code><br>Hello<br>//显示文件/root/mm，可以看到文件的内容是Hello</li></ul></li><li>另外一种特殊的输出重定向是输出追加重定向，即将某一命令执行的输出添加到已经存在的文件中。<br>命令语法：<br>[命令]&gt;&gt;[文件]<ul><li>[例3.26]使用输出追加重定向将数据写入文件/root/ao。<br><code>[root@rhel ~]#echo Hello &gt;/root/ao</code><br>//先创建文件/root/ao，文件内容是Hello<br><code>[root@rhel ~]#echo Linux &gt;&gt;/root/ao</code><br>//向文件/root/ao中追加数据Linux<br><code>[root@rhel ~]#cat/root/ao</code><br>Hello<br>Linux</li></ul></li></ul><h5 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a><strong>输入重定向</strong></h5><ul><li><p>输入重定向，即将某一文件的内容作为命令的输入。<br>命令语法：<br>[命令]&lt;[文件]</p><ul><li>[例3.27]使用输入重定向将文件/root/mm的内容作为输入让cat命令执行。<br><code>[root@rhel ~]#cat &lt;/root/mm</code><br>Hello<br>//可以看到文件/root/mm的内容是Hello</li></ul></li><li><p>另外一种特殊的输入重定向是输入追加重定向，这种输入重定向告诉Shell，当前标准输入来自命令行的一对分隔符之间的内容。<br>命令语法：<br>[命令]&lt;&lt;[分隔符]<br>&gt;[文本内容]<br>&gt;[分隔符]</p><ul><li>[例3.28]使用输入追加重定向创建/root/bc文件。<br><code>[root@rhel ~]#cat &gt;/root/bc &lt;&lt;EOF</code><br><code>\&gt;Hello Linux</code><br><code>\&gt;EOF</code><br>//一般使用EOF作为分隔符</li></ul></li></ul><h5 id="错误重定向"><a href="#错误重定向" class="headerlink" title="错误重定向"></a><strong>错误重定向</strong></h5><ul><li>错误重定向，即将某一命令执行的出错信息输出到指定文件中。<br>命令语法：<br>[命令]2&gt;[文件]<ul><li>[例3.29]查看 根本不存在的/root/kk文件，出现报错信息，将其保存到文件/root/b中。<br><code>[root@rhel ~]#cat/root/kk 2&gt; /root/b</code><br><code>[root@rhel ~]#cat/root/b</code><br>cat：lrootlkk：没有那个文件或目录<br>//使用cat命令查看/root/b文件，可以看到其内容就是执行命令cat/root/kk的报错信息</li></ul></li><li>另外一种特殊的错误重定向是错误追加重定向，即将某一命令执行的出错信息添加到已经存在的文件中<br>命令语法：<br>[命令]2&gt;&gt;[文件]<ul><li>[例3.30]使用错误追加重定向，将执行命令的多次出错信息保存到文件/root/b中。<br><code>[root@rhel ~]#cat/root/kk 2&gt; /root/b</code><br><code>[root@rhel ~]#cat/root/kk 2&gt;&gt; /root/b</code><br><code>[root@rhel ~]#cat/root/b</code><br>cat：/root/kk：没有那个文件或目录cat：/root/kk：没有那个文件或目录</li></ul></li></ul><h5 id="同时实现输出和错误重定向"><a href="#同时实现输出和错误重定向" class="headerlink" title="同时实现输出和错误重定向"></a><strong>同时实现输出和错误重定向</strong></h5><ul><li>同时实现输出和错误的重定向，即可以同时实现输出重定向和错误重定向的功能。<br>命令语法：<br>[命令]&amp;&gt;[文件]<br>[例3.31]同时使用输出和错误重定向。<br><code>[root@rhel ~]#ls/boot &amp;&gt; /root/kk</code><br><code>[root@rhel ~]#cat/root/kk</code><br>config-3.3.4-5.fc17.i686.PAE<br>grub<br>grub2<br>initramfs-3.3.4-5.fc17.i686.PAE.img<br>lost+found<br>System.map-3.3.4-5.fc17.i686.PAE<br>tboot.gz<br>tboot-syms<br>vmlinuz-3.3.4-5.fc17.i686.PAE<br>//因为/boot目录下有文件，所以最终使用了输出重定向</li></ul><h4 id="7-vi编辑器"><a href="#7-vi编辑器" class="headerlink" title="7.vi编辑器"></a>7.vi编辑器</h4><ul><li>文本编辑器有很多，图形模式下有gedit，kwrite等编辑器，文本模式下的编辑器有vi，vim （vi的增强版本）和nano。</li><li>vi和vim是Linux系统中最常用的编辑器，本节主要讲述vi编辑器的使用。</li></ul><h5 id="vi编辑器简介"><a href="#vi编辑器简介" class="headerlink" title="vi编辑器简介"></a><strong>vi编辑器简介</strong></h5><ul><li>vi编辑器是Linux系统字符界面下最常使用的文本编辑器，用于编辑任何ASCII文本，对于编辑源程序尤其有用。vi编辑器功能非常强大，通过使用vi编辑器，可以对文本进行创建、查找、替换、删除、复制和粘贴等操作。</li><li>在Linux系统Shell提示符下输入vi和文件名称后，就进入vi编辑界面。如果系统内还不存在该文件，就意味着创建文件，如果系统内存在该文件，就意味着编辑该文件。</li><li>vi编辑器有3种基本工作模式，分别是命令模式、插入模式和末行模式。</li></ul><h5 id="1、命令模式"><a href="#1、命令模式" class="headerlink" title="1、命令模式"></a><strong>1、命令模式</strong></h5><ul><li>进入vi编辑器之后，系统默认处于命令模 式。命令模式控制屏幕光标的移动，字符、 字或行的删除，某区域的移动、复制等。 在命令模式下，按冒号键“:”可以进入末 行模式，按字母键“a”就可以进入插入模式。</li></ul><h5 id="2、插入模式"><a href="#2、插入模式" class="headerlink" title="2、插入模式"></a><strong>2、插入模式</strong></h5><ul><li>只有在插入模式下，才可以进行文本编辑。在插入模式下按“Esc”键可回到命令模式。</li></ul><h5 id="3、末行模式"><a href="#3、末行模式" class="headerlink" title="3、末行模式"></a><strong>3、末行模式</strong></h5><ul><li>将文件保存或退出vi编辑器，也可以设置 编辑环境、替换字符或删除字符。</li><li>在末行模式下按“Esc”键可以回到命令模式。</li></ul><h5 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a><strong>进入插入模式</strong></h5><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">i</td><td>从光标当前所在位置之前开始插入</td></tr><tr><td align="center">a</td><td>从光标当前所在位置之后开始插入</td></tr><tr><td align="center">I</td><td>在光标所在行的行首插入</td></tr><tr><td align="center">A</td><td>在光标所在行的行末尾插入</td></tr><tr><td align="center">o</td><td>在光标所在的行的下面新开一行插入</td></tr><tr><td align="center">O</td><td>在光标所在的行的上面新开一行插入</td></tr><tr><td align="center">s</td><td>在光标所在的行的上面新开一行插入</td></tr><tr><td align="center">S</td><td>删除光标所在的行，然后进入插入模式</td></tr></tbody></table><h5 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a><strong>光标移动</strong></h5><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">↑</td><td>使光标向上移动一行</td></tr><tr><td align="center">↓</td><td>使光标向下移动一行</td></tr><tr><td align="center">←</td><td>使光标向左移动一行</td></tr><tr><td align="center">→</td><td>使光标向右移动一行</td></tr><tr><td align="center">k</td><td>使光标向上移动一行</td></tr><tr><td align="center">j</td><td>使光标向下移动一行</td></tr><tr><td align="center">h</td><td>使光标向左移动一行</td></tr><tr><td align="center">l</td><td>使光标向右移动一行</td></tr><tr><td align="center">nk</td><td>使光标向上移动n行，n代表数字</td></tr><tr><td align="center">nj</td><td>使光标向下移动n行，n代表数字</td></tr><tr><td align="center">nh</td><td>使光标向左移动n个字符，n代表数字</td></tr><tr><td align="center">nl</td><td>使光标向右移动n个字符，n代表数字</td></tr><tr><td align="center">H</td><td>使光标移动到屏幕的顶部</td></tr><tr><td align="center">M</td><td>使光标移动到屏幕的中间</td></tr><tr><td align="center">L</td><td>使光标移动到屏幕的底部</td></tr><tr><td align="center">Ctrl+b</td><td>使光标往上移动一页屏幕</td></tr><tr><td align="center">Ctrl+f</td><td>使光标往下移动一页屏幕</td></tr><tr><td align="center">Ctrl+u</td><td>使光标往上移动半页屏幕</td></tr><tr><td align="center">Ctrl+d</td><td>使光标往下移动半页屏幕</td></tr><tr><td align="center">数字0</td><td>使光标移到所在行的行首</td></tr><tr><td align="center">$</td><td>使光标移动到光标所在行的行尾</td></tr><tr><td align="center">^</td><td>使光标移动到光标所在行的行首</td></tr><tr><td align="center">w</td><td>使光标跳到下一个字的开头</td></tr><tr><td align="center">W</td><td>使光标跳到下一个字的开头，但会忽略一些标点符号</td></tr><tr><td align="center">e</td><td>使光标跳到下一个字的字尾</td></tr><tr><td align="center">E</td><td>使光标跳到下一个字的字尾，但会忽略一些标点符号</td></tr><tr><td align="center">b</td><td>使光标回到上一个字的开头</td></tr><tr><td align="center">B</td><td>使光标回到上一个字的开头，但会忽略一些标点符号</td></tr><tr><td align="center">(</td><td>使光标移动到上一个句首</td></tr><tr><td align="center">)</td><td>使光标移动到下一个句首</td></tr><tr><td align="center">{</td><td>使光标移动到上一个段落首</td></tr><tr><td align="center">}</td><td>使光标移动到下一个段落首</td></tr><tr><td align="center">G</td><td>使光标移动到文件尾（最后一行的第一个非空白字符处）</td></tr><tr><td align="center">gg</td><td>使光标移动到文件首（第一行第一个非空白字符处）</td></tr><tr><td align="center">Ctrl+p</td><td>使光标向上移动一行</td></tr><tr><td align="center">Ctrl+n</td><td>使光标向下移动一行</td></tr><tr><td align="center">n|</td><td>使光标移动到第n个字符处，n代表数字</td></tr><tr><td align="center">nG</td><td>使光标移动到第n行首，n代表数字</td></tr><tr><td align="center">n+</td><td>使光标向下移动n行，n代表数字</td></tr><tr><td align="center">n-</td><td>使光标向上移动n行，n代表数字</td></tr><tr><td align="center">n$</td><td>使光标移动到以当前行算起的第n行尾，n代表数</td></tr></tbody></table><h5 id="命令模式命令"><a href="#命令模式命令" class="headerlink" title="命令模式命令"></a>命令模式命令</h5><table><thead><tr><th>类型</th><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>删除</td><td>x</td><td>删除光标所在位置的字符</td></tr><tr><td>删除</td><td>X</td><td>删除光标所在位置的前面一个字符</td></tr><tr><td>删除</td><td>nx</td><td>删除光标所在位置开始的n个字符，n代表数字</td></tr><tr><td>删除</td><td>nX</td><td>删除光标所在位置前面n个字符，n代表数字</td></tr><tr><td>删除</td><td>dd</td><td>删除光标所在行</td></tr><tr><td>删除</td><td>ndd</td><td>从光标所在行开始删除n行，n代表数字</td></tr><tr><td>删除</td><td>db</td><td>删除光标所在位置的前面一个单词</td></tr><tr><td>删除</td><td>ndb</td><td>删除光标所在位置的前面n个单词，n代表数字</td></tr><tr><td>删除</td><td>dw</td><td>从光标所在位置开始删除一个单词</td></tr><tr><td>删除</td><td>ndw</td><td>从光标所在位置开始删除几个单词，n代表数字</td></tr><tr><td>删除</td><td>d$</td><td>删除光标到行尾的内容（含光标所在处字符）</td></tr><tr><td>删除</td><td>D</td><td>删除光标到行尾的内容（含光标所在处字符）</td></tr><tr><td>删除</td><td>dG</td><td>从光标位置所在行一直删除到文件尾</td></tr><tr><td>复制和粘贴</td><td>yw</td><td>复制光标所在位置到单词尾的字符</td></tr><tr><td>复制和粘贴</td><td>nyw</td><td>复制光标所在位置开始的n个单词，n代表数字</td></tr><tr><td>复制和粘贴</td><td>yy</td><td>复制光标所在行</td></tr><tr><td>复制和粘贴</td><td>nyy</td><td>复制从光标所在行开始的n行，n代表数字</td></tr><tr><td>复制和粘贴</td><td>y$</td><td>将缓冲区内的内容写到光标所在的位置</td></tr><tr><td>复制和粘贴</td><td>y^</td><td>复制光标前面所在位置到行首内容到缓存区</td></tr><tr><td>复制和粘贴</td><td>YY</td><td>将当前行复制到缓冲区</td></tr><tr><td>复制和粘贴</td><td>nYY</td><td>将当前开始的n行复制到缓冲区，n代表数字</td></tr><tr><td>复制和粘贴</td><td>p</td><td>将缓冲区内的内容写到光标所在的位置</td></tr><tr><td>替换</td><td>r</td><td>替换光标所在处的字符，按[r]键之后输入要替换的字符</td></tr><tr><td>替换</td><td>R</td><td>替换光标所到之处的字符，直到按下[ESC]键为止，按[R]键之后输入要替换的字符</td></tr><tr><td>撤销和重复</td><td>u</td><td>撤销上一个操作。按多次u可以执行多次撤销</td></tr><tr><td>撤销和重复</td><td>U</td><td>取消所有操作</td></tr><tr><td>撤销和重复</td><td>.</td><td>再执行一次前面刚完成的操作</td></tr><tr><td>列出行号</td><td>Ctrl+g</td><td>列出光标所在行的行号</td></tr><tr><td>保存退出</td><td>ZZ</td><td>保存退出</td></tr><tr><td>保存退出</td><td>ZQ</td><td>不保存退出</td></tr><tr><td>查找</td><td>/</td><td>先按[/]键，再输入想查找的字符，如果第一次查找的关键字不是想要的，可以一直按[n]键会往后查找下一个关键字，而按[N]键会往相反的方向查找</td></tr><tr><td>查找</td><td>?</td><td>先按[?]键，再输入想查找的字符，如果第一.次查找的关键字不是想要的，可以一直按[n]键会往前查找下一个关键字，而按[N]键会往相反的方向查找</td></tr></tbody></table><hr><h2 id="update-2020-7-20-20-49-22"><a href="#update-2020-7-20-20-49-22" class="headerlink" title="update: 2020-7-20 20:49:22"></a>update: 2020-7-20 20:49:22</h2><h2 id="四、目录和文件管理"><a href="#四、目录和文件管理" class="headerlink" title="四、目录和文件管理"></a>四、目录和文件管理</h2><pre><code>Linux系统与Windows系统有很大的不同， 它以目录的形式挂载文件系统，其目录结 构是一个分层的树形结构。链接是一种在 共享文件和访问它的用户的若干目录项之 间建立联系的方法，Linux系统中包括硬链接和软链接两种方式。</code></pre><h4 id="1-Linux文件类型"><a href="#1-Linux文件类型" class="headerlink" title="1.Linux文件类型"></a>1.Linux文件类型</h4><ul><li>在Linux系统中除了一般文件之外，所有的目录和设备（如光驱、硬盘等）都是以文 件的形式存在的。 Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。</li><li>通过一般应用程序创建的文件，比如file.txt、file.tar.gz，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多称之为普通文件。</li><li>Linux文件类型常见的有：普通文件、目录文件、设备文件（字符设备文件和块设备文件）、管道文件和符号链接文件等。</li></ul><h5 id="1-普通文件"><a href="#1-普通文件" class="headerlink" title="1.普通文件"></a>1.普通文件</h5><ul><li>用“ls -lh”命令查看某个文件的属性， 可以看到有类似“-rw——-”的属性符 号，其属性第一个符号是“-”，这样的文 件在Linux系统中就是普通文件。这些文件 一般是用一些相关的应用程序创建，比如<br>图像工具、文档工具或归档工具等。</li></ul><h5 id="2-目录文件"><a href="#2-目录文件" class="headerlink" title="2.目录文件"></a>2.目录文件</h5><ul><li>当在某个目录下执行“ls -lh”命令，看 到有类似“drwxr-xr-x”的属性符号，其 属性第一个符号是“d”，这样的文件在Linux系统中就是目录文件。</li></ul><h5 id="3-设备文件"><a href="#3-设备文件" class="headerlink" title="3.设备文件"></a>3.设备文件</h5><ul><li>Linux系统中的/dev目录中有大量的设备文 件，主要是块设备文件和字符设备文件。<ul><li>（1）块设备文件 块设备的主要特点是可以随机读写，而最 常见的块设备就是磁盘，如/dev/hda1、 /dev/sda1等。用“ls -l”命令查看某个文件的属性，可以看到有类似“brw-rw—”的属性符号，其属性第一个符号是 “b”，这样的文件在Linux系统中就是块设备文件。</li><li>（2）字符设备文件 最常见的字符设备文件是打印机和终端， 可以接收字符流。/dev/null是一个非常有 用的字符设备文件，送入这个设备的所有 内容都被忽略。用“ls -l”命令查看某个文件的属性，可以看到有类似“crw–w—”的属性符号，其属性第一个符号是 “c”，这样的文件在Linux系统中就是字符设备文件。</li></ul></li></ul><h5 id="4-管道文件"><a href="#4-管道文件" class="headerlink" title="4.管道文件"></a>4.管道文件</h5><ul><li>管道文件有时候也被叫做FIFO文件（FIFO 是先进先出的意思），管道文件就是从一 头流入，从另一头流出。用“ls -l”命令查看某个文件的属性，可以看到有类似 “prw——-”的属性符号，其属性第一 个符号是“p”，这样的文件在Linux系统中就是管道文件。</li></ul><h5 id="5-链接文件"><a href="#5-链接文件" class="headerlink" title="5.链接文件"></a>5.链接文件</h5><ul><li>链接文件有两种类型：软链接文件和硬链接文件。 <ul><li>（1）软链接文件<ul><li>软链接文件又叫符号链接文件，这个文件包含了另一个文 件的路径名。其可以是任意文件或目录，可以链接不同文 件系统的文件。在对软链接文件进行读写的时候，系统会 自动地把该操作转换为对源文件的操作，但删除软链接文 件时，系统仅仅删除软链接文件，而不删除源文件本身。</li><li>用“ls -l”命令查看某个文件的属性，可以看到有类似“lrwxrwxrwx”的属性符号，其属性第一个符号是“l”，这样的文件在Linux系统中就是软链接文件。</li></ul></li><li>（2）硬链接文件<ul><li>硬链接是已存在文件的另一个文件，对硬链接文件进行读写和删除操作时，结果和软链接相同。但如果删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了原有的 内容。这时，系统就“记”了它曾经是硬链接文件，而把它当成一个普通文件。</li><li>用“ls -l”命令查看某个文件的属性，可以看到第二列 的文件硬链接数大于1 ，这样的文件在Linux系统中就是硬链接文件。</li></ul></li></ul></li></ul><h4 id="2-Linux目录结构"><a href="#2-Linux目录结构" class="headerlink" title="2.Linux目录结构"></a>2.Linux目录结构</h4><ul><li>Linux系统都有根文件系统，它包含系统引 导和使其它文件系统得以挂载所必要的文 件，根文件系统需要有单用户状态所必须 的足够的内容，还应该包括修复损坏系统、 恢复备份等工具。</li><li>Linux系统的目录结构是分层的树形结构，<br>都是挂载在根文件系统“/”下。</li></ul><h5 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h5><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>/home</td><td>包含Linux系统上各用户的主目录，子目录名称默认以该用户 名命名</td></tr><tr><td>/root</td><td>是root用户的主目录</td></tr><tr><td>/bin</td><td>包含常用的命令文件，不能包含子目录</td></tr><tr><td>/sbin</td><td>包含系统管理员和root用户所使用的命令文件</td></tr><tr><td>/dev</td><td>包含大部分的设备文件，比如磁盘、光驱等</td></tr><tr><td>/lib</td><td>包含Linux系统的共享文件和内核模块文件 /lib/modules目录存放核心可加载模块</td></tr><tr><td>/lib64</td><td>包含64位版本Linux系统的共享文件和内核模块文件</td></tr><tr><td>/tmp</td><td>包含一些临时文件</td></tr><tr><td>/mnt</td><td>手动为某些设备（比如硬盘）挂载提供挂载目录</td></tr><tr><td>/boot</td><td>包含Linux系统的内核文件和引导装载程序（如GRUB）文件</td></tr><tr><td>/opt</td><td>包含某些第三方应用程序的安装文件</td></tr><tr><td>/media</td><td>由系统自动为某些设备（一般为光盘、U盘等设备）挂载提供挂载目录</td></tr><tr><td>/var</td><td>该目录存放不经常变化的数据，如系统日志、打印队列、DNS数据库文件等</td></tr><tr><td>/etc</td><td>包含Linux系统上大部分的配置文件，建议修改配置文件之前先备份</td></tr><tr><td>/usr</td><td>包含可以供所有用户使用的程序和数据</td></tr><tr><td>/srv</td><td>存储一些服务启动之后所需要取用的资料目录</td></tr><tr><td>/run</td><td>一个临时文件系统，一些程序或服务启动以后，会将他们的PID放置在该目录中</td></tr><tr><td>/sys</td><td>在Linux系统提供热插拔能力的同时，该目录包含所检测到的硬件设置，它们被 转换成/dev目录中的设备文件</td></tr><tr><td>/proc</td><td>是一个虚拟的文件系统，它不存在磁盘上，而是由内核在内存中产生， 用于提供系统的相关信息。 下面说明在/proc目录下的一些最重要的文件。<br/>/proc/cpuinfo：该文件保存计算机CPU信息。 <br/>/proc/filesystems：该文件保存Linux文件系统信息。 <br/>/proc/ioports：该文件保存计算机I/O端口号信息。 <br/>/proc/version：该文件保存Linux系统版本信息。<br/>/proc/meminfo：该文件保存计算机内存信息。</td></tr></tbody></table><h4 id="3-文件和目录操作"><a href="#3-文件和目录操作" class="headerlink" title="3.文件和目录操作"></a>3.文件和目录操作</h4><ul><li>本节主要讲述在Linux系统下如何使用命令 对文件和目录进行操作，涉及的命令有pwd、cd、ls、touch、mkdir、rmdir、cp、mv、rm、wc等。</li></ul><h5 id="pwd：显示工作目录路径"><a href="#pwd：显示工作目录路径" class="headerlink" title="pwd：显示工作目录路径"></a>pwd：显示工作目录路径</h5><ul><li>显示当前用户所处的工作目录的绝对路径。</li><li>命令语法： pwd [选项]<br>【例4.1】 显示用户当前工作目录路径。<br><code>[root@rhel sysconfig]# pwd</code><br>/etc/sysconfig<br>//用户当前工作目录路径是/etc/sysconfig</li></ul><h5 id="cd：更改工作目录路径"><a href="#cd：更改工作目录路径" class="headerlink" title="cd：更改工作目录路径"></a>cd：更改工作目录路径</h5><ul><li>更改用户的工作目录路径。工作目录路径 可以使用绝对路径名或相对路径名，绝对 路径从/（根）开始，然后循序到所需的目录下，相对路径从当前目录开始。</li><li>命令语法： cd [选项] [目录]<br>【例4.2】 更改用户工作目录路径为/etc。<br><code>[root@rhel sysconfig]# cd /etc</code><br><code>[root@rhel etc]# pwd</code><br>/etc<br>//查看当前目录，已经更改为/etc了<br>【例4.3】 更改目录位置至当前目录的父目录。<br><code>[root@rhel etc]# pwd</code><br>/etc<br><code>[root@rhel etc]# cd ..</code><br><code>[root@rhel /]# pwd</code><br>/<br>//可以看到目录已经更改为当前目录的父级目录“/”了<br>【例4.4】 更改目录位置为用户主目录。<br><code>[root@rhel /]# pwd</code><br><code>/</code><br><code>[root@rhel /]# cd ~</code><br><code>[root@rhel ~]# pwd</code><br><code>/root</code><br>//可以看到目录已经更改为当前用户的主目录<br>【例4.5】 更改目录位置至用户zhangsan的主目录。<br><code>[root@rhel ~]# cd ~zhangsan</code><br><code>[root@rhel zhangsan]# pwd</code><br><code>/home/zhangsan</code><br>//可以看到目录已经更改为用户zhangsan的主目录/home/zhangsan</li></ul><h5 id="ls：列出目录和文件信息"><a href="#ls：列出目录和文件信息" class="headerlink" title="ls：列出目录和文件信息"></a>ls：列出目录和文件信息</h5><ul><li>对于目录而言将列出其中的所有子目录与 文件信息；对于文件而言将输出其文件名 以及所要求的其它信息。</li><li>命令语法：ls [选项] [目录|文件]</li></ul><p><strong>ls命令显示的详细信息</strong></p><table><thead><tr><th align="center">列数</th><th>描述</th></tr></thead><tbody><tr><td align="center">1</td><td>第1个字符表示文件的类型 <br/>第2～4个字符表示文件的用户所有者对此文件的访问权限 <br/>第5～7个字符表示文件的组群所有者对此文件的访问权限<br/>第8～10个字符表示其他用户对此文件的访问权限</td></tr><tr><td align="center">2</td><td>文件的链接数</td></tr><tr><td align="center">3</td><td>文件的用户所有者</td></tr><tr><td align="center">4</td><td>文件的组群所有者</td></tr><tr><td align="center">5</td><td>文件长度（也就是文件大小，不是文件的磁盘占用量）</td></tr><tr><td align="center">6~8</td><td>文件的更改时间（mtime）， 或者是文件的最后访问时间（atime）</td></tr><tr><td align="center">9</td><td>文件名称</td></tr></tbody></table><h5 id="touch：创建空文件、更改文件时间"><a href="#touch：创建空文件、更改文件时间" class="headerlink" title="touch：创建空文件、更改文件时间"></a>touch：创建空文件、更改文件时间</h5><ul><li>创建空文件以及更改文件的时间（atime和 mtime）。 </li><li>命令语法：touch [选项] [文件]</li><li>【例4.9】 创建空文件file，file1和file2。<br><code>[root@rhel ~]# touch file1</code><br><code>[root@rhel ~]# touch file2 file3</code><br><code>[root@rhel ~]# ls -l file1 file2 file3</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file1</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file2</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file3</code><br>//file1，file2，file3这3个都是空文件，文件内没有任何数据</li><li>【例4.10】将文件file1的时间记录改为6月7日19点 30分，时间格式为MMDDHHmm。<br><code>[root@rhel ~]# ls -l file1</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file1</code><br>//空文件file1其创建日期为6月3日5:45<br><code>[root@rhel ~]# touch -c -t 06071930 file1</code><br><code>[root@rhel ~]# ls -l file1 -rw-r--r--. 1 root root 0 6月 7 19:30 file1</code><br>//可以看到文件file1现在的时间已经改为6月7日19点30分</li></ul><h5 id="mkdir：创建目录"><a href="#mkdir：创建目录" class="headerlink" title="mkdir：创建目录"></a>mkdir：创建目录</h5><ul><li>在Linux系统中创建目录。</li><li>命令语法：mkdir [选项] [目录] </li><li>【例4.11】 创建目录newdir1，其默认权限为755。<br>[root@rhel ~]# mkdir newdir1<br>[root@rhel ~]# ls -ld<br>drwxr-xr-x. 2 root root 4096 6月 3 05:46 newdir1<br>//目录newdir1的权限为rwxr-xr-x（755）</li></ul><h5 id="rmdir：删除空目录"><a href="#rmdir：删除空目录" class="headerlink" title="rmdir：删除空目录"></a>rmdir：删除空目录</h5><ul><li>在Linux系统中删除空目录。 </li><li>命令语法： rmdir [选项] [目录] </li><li>【例4.13】 删除空目录newdir1。<br>[root@rhel ~]# rmdir newdir1</li></ul><h5 id="cp：复制文件和目录"><a href="#cp：复制文件和目录" class="headerlink" title="cp：复制文件和目录"></a>cp：复制文件和目录</h5><ul><li>复制文件和目录到其它目录中。如果同时 指定两个以上的文件或目录，且最后的目 的地是一个已经存在的目录，则它会把前 面指定的所有文件或目录复制到该目录中。 若同时指定多个文件或目录，而最后的目 的地并非是一个已存在的目录，则会出现 错误信息。 </li><li>命令语法：cp [选项] [源文件|目录] [目标文件|目录]</li><li>【例4.15】 将/etc/grub2.cfg文件复制到/root目 录下，并改名为grub。<br><code>[root@rhel ~]# cp /etc/grub2.cfg /root/grub</code><br>【例4.16】 将文件/etc/grub2.cfg复制到/root目 录下。<br><code>[root@rhel ~]# cp /etc/grub2.cfg /root</code><br>【例4.17】 将/boot目录中的所有文件及其子目录 复制到目录/root中。<br><code>[root@rhel ~]# cp -r /boot /root</code></li></ul><h5 id="mv：文件和目录改名、移动文件和目录路径"><a href="#mv：文件和目录改名、移动文件和目录路径" class="headerlink" title="mv：文件和目录改名、移动文件和目录路径"></a>mv：文件和目录改名、移动文件和目录路径</h5><ul><li>对文件和目录更改名称以及移动文件和目 录的路径。 </li><li>命令语法：mv [选项] [源文件|目录] [目标文件|目录]</li><li>【例4.18】 将/root/picture目录下所有的后缀名为“.png” 的文件移到/usr/local/share/picture目录下。<br><code>[root@rhel ~]# mv -f /root/picture/*.png /usr/local/share/picture</code><br>【例4.19】 把/root/picture目录下的文件kdepic.png改名 为life.png。<br><code>[root@rhel ~]# mv /root/picture/kdepic.png /root/picture/life.png</code><br>【例4.20】 把目录/root/pitcure名称更改为 /root/mypicture。<br><code>[root@rhel ~]# mv /root/picture /root/mypicture</code></li></ul><h5 id="rm：删除文件或目录"><a href="#rm：删除文件或目录" class="headerlink" title="rm：删除文件或目录"></a>rm：删除文件或目录</h5><ul><li>删除系统中的文件或目录。 </li><li>命令语法：rm [选项] [文件|目录]</li><li>【例4.21】 删除当前目录下的file4文件。<br><code>[root@rhel ~]#rm file4 rm：是否删除普通文件“file4”? y</code><br>//输入y确认删除该文件<br>【例4.22】 连同文件/root/ab/a和目录/root/ab一起删除。<br><code>[root@rhel ~]# mkdir /root/ab</code><br><code>[root@rhel ~]# touch /root/ab/a</code><br>//创建目录/root/ab和文件/root/ab/a<br><code>[root@rhel ~]# rm -rf /root/ab</code><br>//连同文件/root/ab/a和目录/root/ab一起删除</li></ul><h5 id="wc：统计文件行数、单词数和字节数和字符数"><a href="#wc：统计文件行数、单词数和字节数和字符数" class="headerlink" title="wc：统计文件行数、单词数和字节数和字符数"></a>wc：统计文件行数、单词数和字节数和字符数</h5><ul><li>统计指定文件的行数、单词数、字节数和 字符数，并将统计结果显示输出到屏幕。 如果没有给出文件名，则从标准输入读取。 wc同时也给出所有指定文件的总统计数。 单词是由空格字符区分开的最大字符串。 输出列的顺序和数目不受选项的顺序和数目的影响。总是按行数、单词数、字节数、 文件的顺序显示每项信息。 </li><li>命令语法：wc [选项] [文件]</li><li>【例4.23】 统计/root/aa文件的行数、单词数和 字符数。<br><code>[root@rhel ~]#cat /root/aa</code><br>a b<br>c de f<br>中国 g h<br>//查看/root/aa文件内容<br><code>[root@rhel ~]#wc /root/aa</code><br>3 8 22 /root/aa</li></ul><h4 id="4-链接文件"><a href="#4-链接文件" class="headerlink" title="4.链接文件"></a>4.链接文件</h4><ul><li>在Linux系统中，内核为每一个新创建的文 件分配一个inode（索引节点）号，文件属 性保存在索引节点里，在访问文件时，索 引节点被复制到内存里，从而实现文件的快速访问。</li></ul><h5 id="链接文件简介"><a href="#链接文件简介" class="headerlink" title="链接文件简介"></a>链接文件简介</h5><ul><li><p>链接是一种在共享文件和访问它的用户的 若干目录项之间建立联系的方法。Linux系 统中包括硬链接和软链接（也被称为符号链接）两种。</p><ul><li><p>硬链接</p><p>硬链接是一个指针，指向文件inode，系统 并不为它重新分配inode，两文件具有相同的inode。硬链接节省空间，也是Linux系统整合文件系统的传统方式。<br>硬链接文件有两个限制：<br>（1）不允许给目录创建硬链接；<br>（2）只有在同一文件系统中的文件之间才能创建链接。</p></li><li><p>软链接</p><p>软链接也叫符号链接，这个文件包含了另 一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件，和 Windows下的快捷方式相似。链接文件甚 至可以链接不存在的文件，这就产生一般 称之为“断链”的问题，链接文件甚至可以循环链接自己。</p></li></ul></li><li><p>硬链接和软链接的区别</p><p>硬链接记录的是目标的inode，软链接记录 的是目标的路径。软链接就像是快捷方式， 而硬链接就像是备份。软链接可以做跨分 区的链接，而硬链接由于inode的缘故，只 能在本分区中做链接。所以软链接的使用频率要高得多。</p></li></ul><h5 id="创建和使用链接文件"><a href="#创建和使用链接文件" class="headerlink" title="创建和使用链接文件"></a>创建和使用链接文件</h5><ul><li>使用ln命令可以创建链接文件（包括软链 接文件和硬链接文件）。 </li><li>命令语法：ln [选项] [源文件名] [链接文件名]</li><li>【例4.25】 硬链接文件的使用。<br><code>[root@rhel ~]#echo hello &gt; a [root@rhel ~]#ln a b</code><br>【例4.26】 软链接文件的使用。<br><code>[root@rhel ~]#echo hello &gt; a</code><br><code>[root@rhel ~]#ln –s a b</code></li></ul><h2 id="五、Linux常用命令"><a href="#五、Linux常用命令" class="headerlink" title="五、Linux常用命令"></a>五、Linux常用命令</h2><h4 id="1-文本内容显示"><a href="#1-文本内容显示" class="headerlink" title="1.文本内容显示"></a>1.文本内容显示</h4><ul><li>本节主要讲述Linux系统中文本内容显示的相关命令，这些命令有cat，more，less，head，tail，(tail -f)</li></ul><h5 id="cat：显示文本文件"><a href="#cat：显示文本文件" class="headerlink" title="cat：显示文本文件"></a>cat：显示文本文件</h5><ul><li>显示文本文件的内容，也可以把几个文件内容附加到另一个文件中。如果没有指定 文件，或者文件为“-”，那么就从标准输入读取。</li><li>命令语法：cat [选项] [文件]</li><li>【例5.1】 显示/etc/inittab文件的内容。 [root@rhel ~]# cat /etc/inittab<br>【例5.2】 把textfile1文件的内容加上行号后输 入到textfile2文件中。<br><code>[root@rhel ~]# cat -n textfile1 &gt; textfile2</code><br>【例5.3】 使用cat命令创建mm.txt。<br><code>[root@rhel ~]#cat &gt;mm.txt&lt;&lt;EOF</code><br><code>\&gt;Hello</code><br><code>\&gt;Linux</code><br><code>\&gt;EOF</code> //在此输入字符EOF，会自动回到shell提示符界面</li></ul><h5 id="more：分页显示文本文件"><a href="#more：分页显示文本文件" class="headerlink" title="more：分页显示文本文件"></a>more：分页显示文本文件</h5><ul><li>分页显示文本文件的内容。类似于cat命令， 不过是以分页方式显示文件内容，方便使 用者逐页阅读，其最基本的按键就是按空 格键就显示下一页内容，按[b]键返回显示 上一页内容。 </li><li>命令语法：more [选项] [文件名]</li><li>【例5.4】 分页显示/etc/services文件的内容。<br><code>[root@rhel ~]# more /etc/services</code><br>【例5.5】 逐页显示testfile文件内容，如有连续两行以上 空白行则以一行空白行显示。<br><code>[root@rhel ~]# more -s testfile</code><br>【例5.6】 从第20行开始显示testfile文件的内容。<br><code>[root@rhel ~]# more +20 testfile</code><br>【例5.7】 一次两行显示/etc/passwd文件内容。<br><code>[root@rhel ~]# more -2 /etc/passwd</code></li></ul><h5 id="less：回卷显示文本文件"><a href="#less：回卷显示文本文件" class="headerlink" title="less：回卷显示文本文件"></a>less：回卷显示文本文件</h5><ul><li>回卷显示文本文件的内容。less命令的作 用与more十分相似，都可以用来浏览文本 文件的内容，不同的是less命令允许使用 者往回卷动。 </li><li>命令语法：less [选项] [文件名]</li><li>【例5.8】 回卷显示/etc/services文件的内容。<br><code>[root@rhel ~]# less /etc/services</code></li></ul><h5 id="head：显示指定文件前若干行"><a href="#head：显示指定文件前若干行" class="headerlink" title="head：显示指定文件前若干行"></a>head：显示指定文件前若干行</h5><ul><li>显示指定文件的前若干行文件内容。如果没有给出具体行数值，默认缺省设置为10 行。如果没有指定文件，head就从标准输入读取。 </li><li>命令语法：head［选项］[文件]</li><li>【例5.9】 查看/etc/passwd文件的前100个字节数据内容。<br><code>[root@rhel ~]# head –c 100 /etc/passwd</code><br><code>root:x:0:0:root:/root:/bin/bash</code><br><code>bin:\x:1:1:bin:/bin:/sbin/nologin</code><br><code>daemon:x:2:2:daemon:/sbin:/sbin/nol</code><br>【例5.10】 查看/etc/passwd文件的前3行数据内容。<br><code>[root@rhel ~]# head -3 /etc/passwd</code><br><code>root:x:0:0:root:/root:/bin/bash</code><br><code>bin:x:1:1:bin:/bin:/sbin/nologin</code><br><code>daemon:x:2:2:daemon:/sbin:/sbin/nologin</code></li></ul><h5 id="tail：查看文件末尾数据"><a href="#tail：查看文件末尾数据" class="headerlink" title="tail：查看文件末尾数据"></a>tail：查看文件末尾数据</h5><ul><li>查看文件的末尾数据，默认显示指定文件的 最后10 行到标准输出。如果指定了多个文 件，tail会在每段输出的开始添加相应文件 名作为头。如果不指定文件或文件为“-”， 则从标准输入读取数据。 </li><li>命令语法：tail [选项] [文件名]</li><li>【例5.11】查看/etc/passwd文件末尾3行数据内容。<br><code>[root@rhel ~]# tail -3 /etc/passwd</code><br><code>news:x:9:13:News server user:/etc/news:/bin/bash</code><br><code>distcache:x:94:94:Distcache:/:/sbin/nologin</code><br><code>tcpdump:x:72:72::/:/sbin/nologin</code><br>【例5.12】 查看文件/etc/passwd末尾100字节的数据内容。<br><code>[root@rhel ~]# tail -c 100 /etc/passwd</code><br><code>er:/etc/news:/bin/bash</code><br><code>distcache:x:94:94:Distcache:/:/sbin/nologin</code><br><code>tcpdump:x:72:72::/:/sbin/nologin</code></li><li>tail -f 可以实时刷新末尾数据</li></ul><h4 id="2-文本内容处理"><a href="#2-文本内容处理" class="headerlink" title="2.文本内容处理"></a>2.文本内容处理</h4><ul><li>本节主要讲述Linux系统中文本内容处理的相关命令，这些命令有sort，uniq，cut，comm，diff(diff3)。</li></ul><h5 id="sort：对文件中的数据进行排序"><a href="#sort：对文件中的数据进行排序" class="headerlink" title="sort：对文件中的数据进行排序"></a>sort：对文件中的数据进行排序</h5><ul><li>对文件中的数据进行排序，并将结果显示 在标准输出上。 </li><li>命令语法：sort [选项] [文件]</li><li>【例5.13】 将文件textfile1数据排序，并显示在屏幕上。<br><code>[root@rhel ~]# sort textfile1</code><br><code>a</code><br><code>b</code><br><code>c</code><br>【例5.14】读取textfile1文件内容，以倒序排序该文件并显 示在屏幕上。<br><code>[root@rhel ~]# sort -r textfile1</code><br><code>c</code><br><code>b</code><br><code>a</code></li></ul><h5 id="uniq：将重复行从输出文件中删除"><a href="#uniq：将重复行从输出文件中删除" class="headerlink" title="uniq：将重复行从输出文件中删除"></a>uniq：将重复行从输出文件中删除</h5><ul><li>将文件内的重复行数据从输出文件中删除， 只留下每条记录的惟一样本。 </li><li>命令语法：uniq [选项] [文件]</li><li>【例5.15】查看文件file3中重复的数据内容。<br><code>[root@rhel ~]# cat file3 aaa aaa bbb</code><br><code>[root@rhel ~]# uniq -d file3 aaa</code><br>//file3文件中重复行数据的内容为aaa<br>【例5.16】查看文件file3中不重复的数据内容。<br><code>[root@rhel ~]# uniq -u file3</code><br>bbb //file3文件中不重复行数据的内容为bbb</li></ul><h5 id="cut：从文件每行中显示出选定的字节、字符或字段"><a href="#cut：从文件每行中显示出选定的字节、字符或字段" class="headerlink" title="cut：从文件每行中显示出选定的字节、字符或字段"></a>cut：从文件每行中显示出选定的字节、字符或字段</h5><ul><li>从文件的每行中输出选定的字节、字符或字段（域）。只能使用-b、-c或-f选项中的 一个。每一个列表都是专门为一个类别作 出的，或者可以用逗号隔开要同时显示的 不同类别。输入顺序将作为读取顺序，每 个仅能输入一次。</li><li>命令语法：cut [选项] [ 文件 ]</li><li>【例5.17】显示文件/etc/passwd中的用户登录名和用户名全 称字段，这是第1个和第5个字段，由冒号隔开。<br><code>[root@rhel ~]# cut -f 1,5 -d: /etc/passwd</code><br>root:root<br>bin:bin<br>daemon:daemon<br>adm:adm<br>lp:lp<br>……</li></ul><h5 id="comm：逐行比较两个已排过序的文件"><a href="#comm：逐行比较两个已排过序的文件" class="headerlink" title="comm：逐行比较两个已排过序的文件"></a>comm：逐行比较两个已排过序的文件</h5><ul><li><p>比较两个已排过序的文件，并将其结果显 示出来。 </p></li><li><p>命令语法：<br>comm [选项] [文件1] [文件2]</p><table><thead><tr><th>选项</th><th>选项含义</th></tr></thead><tbody><tr><td>-1</td><td>不输出文件1特有的行</td></tr><tr><td>-2</td><td>不输出文件2特有的行</td></tr><tr><td>-3</td><td>不输出两个文件共有的行</td></tr></tbody></table><p>如果没有指定任何参数，comm命令读取这两个文件，然后输出三列：第 1列输出file1中特有的行；第2列输出file2中特有的行；第3列输出两个文件中共有的行。</p></li><li><p>【例5.18】 比较文件file1和file2文件内容。<br><code>[root@rhel ~]# cat file1</code><br>a<br>aa<br><code>[root@rhel ~]# cat file2</code><br>a<br>bb<br>//查看文件file1和file2的文件内容<br><code>[root@rhel ~]# comm file1 file2</code> </p><pre><code>a</code></pre><p>aa </p><pre><code>bb</code></pre><p>【例5.19】 比较文件file1和file2，只显示文件file1和file2中相同行的数据内容。 <code>[root@rhel ~]# comm -12 file1 file2</code><br>a<br>//file1和file2文件中相同行的数据内容是a</p></li></ul><h5 id="diff：逐行比较两个文本文件，列出其不同之处"><a href="#diff：逐行比较两个文本文件，列出其不同之处" class="headerlink" title="diff：逐行比较两个文本文件，列出其不同之处"></a>diff：逐行比较两个文本文件，列出其不同之处</h5><ul><li><p>逐行比较两个文本文件，列出其不同之处。 它比comm命令能完成更复杂的检查，它对 给出的文件进行系统的检查，并显示出两 个文件中所有不同的行，不要求事先对文 件进行排序。 </p></li><li><p>命令语法：diff ［选项］ [文件1] [文件2]</p></li><li><p>【例5.20】 比较file1和file2文件，列出其不同之处。<br><code>[root@rhel ~]# cat file1</code><br>a<br>aa<br><code>[root@rhel ~]# cat file2</code><br>a<br>bb<br>//查看文件file1和file2的文件内容<br><code>[root@rhel ~]# diff file1 file2</code><br>2c2<br>&lt; aa<br>-–<br>&gt; bb<br>//可以看到file1和file2文件的不同处是第二行的aa和bb</p></li></ul><h4 id="3-文件和命令查找"><a href="#3-文件和命令查找" class="headerlink" title="3.文件和命令查找"></a>3.文件和命令查找</h4><h4 id="4-系统信息显示"><a href="#4-系统信息显示" class="headerlink" title="4.系统信息显示"></a>4.系统信息显示</h4><h4 id="5-日期和时间"><a href="#5-日期和时间" class="headerlink" title="5.日期和时间"></a>5.日期和时间</h4><h4 id="6-信息交流"><a href="#6-信息交流" class="headerlink" title="6.信息交流"></a>6.信息交流</h4><h4 id="7-其他命令"><a href="#7-其他命令" class="headerlink" title="7.其他命令"></a>7.其他命令</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Linux系统的组成&quot;&gt;&lt;a href=&quot;#一、Linux系统的组成&quot; class=&quot;headerlink&quot; title=&quot;一、Linux系统的组成&quot;&gt;&lt;/a&gt;一、Linux系统的组成&lt;/h2&gt;&lt;h4 id=&quot;1-内核&quot;&gt;&lt;a href=&quot;#1-内核&quot; cla
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>知识点概览</title>
    <link href="http://yoursite.com/2020/06/20/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2020/06/20/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/</id>
    <published>2020-06-20T12:46:02.000Z</published>
    <updated>2020-06-20T12:54:35.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul><li><p>顺序、选择、循环</p></li><li><p>文件读写</p></li><li><p>String</p></li><li><p>ArrayList</p></li><li><p>数据建模、算法建模</p></li><li><p>递归、高阶函数</p></li><li><p>Register machine</p></li><li><p>Lambda演算</p></li><li><p>程序正确性验证（不考）</p></li><li><p>软件开发生命周期</p></li><li><p>结构化方法和面向对象方法</p></li><li><p>整数、浮点数操作</p></li><li><p>Overriding Vs Overloading</p></li><li><p>封装</p></li><li><p>职责、协作</p></li><li><p>类之间的关系</p></li><li><p>继承</p></li><li><p>多态</p></li><li><p>继承vs组合</p></li><li><p>类的初始化</p></li><li><p>接口</p></li><li><p>针对接口编程</p></li><li><p>可修改性</p></li><li><p>异常</p></li><li><p>GUI控件、布局、事件响应</p></li><li><p>网络、线程、synchronize</p></li><li><p>Java字节码解析</p></li><li><p>Jvm指令的执行</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li><h4 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h4><ul><li>自顶向下逐步求精</li><li>树状结构</li><li>数据流图</li><li>结构图</li></ul></li><li><h4 id="单个类封装"><a href="#单个类封装" class="headerlink" title="单个类封装"></a>单个类封装</h4><ul><li>数据和行为的在一起</li><li>单一职责</li></ul></li><li><h4 id="多个类封装"><a href="#多个类封装" class="headerlink" title="多个类封装"></a>多个类封装</h4><ul><li>委托</li><li>职责的分配</li></ul></li><li><h4 id="可修改性"><a href="#可修改性" class="headerlink" title="可修改性"></a>可修改性</h4><ul><li>实现的修改（封装）</li><li>扩展（继承，多态）</li><li>灵活性（组合+接口）</li></ul></li></ul><h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><ul><li>lambda演算主要考推演过程</li><li>高阶函数主要考思想，不在乎具体语言</li><li>用例图、数据流图、结构图、类图会考，标准UML</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;知识点：&quot;&gt;&lt;a href=&quot;#知识点：&quot; class=&quot;headerlink&quot; title=&quot;知识点：&quot;&gt;&lt;/a&gt;知识点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;顺序、选择、循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件读写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strin
      
    
    </summary>
    
    
      <category term="软工一笔记" scheme="http://yoursite.com/categories/%E8%BD%AF%E5%B7%A5%E4%B8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="review" scheme="http://yoursite.com/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://yoursite.com/2020/06/14/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/06/14/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-06-14T12:27:07.000Z</published>
    <updated>2020-06-14T12:42:57.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Linux_01.png" alt="img_1"></p><h3 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h3><h4 id="1-用户操作"><a href="#1-用户操作" class="headerlink" title="1. 用户操作"></a>1. 用户操作</h4><p># 表示权限用户(如:root),$ 表示普通用户<br>开机提示:Login:输入用户名<br>password:输入口令 用户是系统注册用户成功登陆后，可以进入相应的用户环境.<br>退出当前shell,输入:exit</p><p>useradd netseek 添加一个netseek用户<br>passwd netseek 给netseek这个用户设置密码.<br>(/etc/passwd /etc/group)<br>userdel netseek 删除账号<br>userdel -r netseek 删除账号连同自家目录</p><h4 id="2-设置linux时间和日期"><a href="#2-设置linux时间和日期" class="headerlink" title="2. 设置linux时间和日期"></a>2. 设置linux时间和日期</h4><p>date 命令(“date MMDDhhmmYYYY.ss”)<br>2006年7月24日12:37 ,30秒<br>date 072412372006.30<br>date -s 20:30:30 #设置系统时间为20: 30:30<br>date -s 2006-7-24 #设置系统时期为2006-7-24<br>clock -r #对系统Bios中读取时间参数<br>clock -w #将系统时间(如由date设置的时间)写入Bios</p><h3 id="二、文件-文件夹操作"><a href="#二、文件-文件夹操作" class="headerlink" title="二、文件/文件夹操作"></a>二、文件/文件夹操作</h3><h4 id="1-查看操作"><a href="#1-查看操作" class="headerlink" title="1. 查看操作"></a>1. 查看操作</h4><p>ls -l 显示文件列表<br>ls -al -a 显示所有档案及目录 (ls内定将档案名或目录名称开头为”.”的视为隐藏档，不会列出)<br>ls -al |grep ‘^d’ 显示目录<br>ls -al |grep ‘^[^d]’ 在一个目录中查询不包含目录的所有文件<br>ls -sh (man ls 查看man帮助.)</p><h4 id="2-linux几种文件类型"><a href="#2-linux几种文件类型" class="headerlink" title="2. linux几种文件类型:"></a>2. linux几种文件类型:</h4><p>d 表示此文件是一个目录<br>- 表示此文件是一个普通文件<br>b 表示此文件是一个特殊的块设备I/O文件<br>c 表示此文件是一个特殊的字符设备I/O文件<br>l 表示此文件是一个连接文件。在其文件名称后紧跟与它连接的文件路径及名称</p><h4 id="3-建立文件和目录"><a href="#3-建立文件和目录" class="headerlink" title="3. 建立文件和目录"></a>3. 建立文件和目录</h4><p>touch 1.txt<br>cat &gt; 2.txt (用定向符创建文件，填写内容后，按ctrl+d保存内容)<br>mkdir mywork 建立mywork这个目录</p><h4 id="4-拷贝文件或目录"><a href="#4-拷贝文件或目录" class="headerlink" title="4. 拷贝文件或目录"></a>4. 拷贝文件或目录</h4><p>cp filename1 filename2<br>cp -r dir1 dir2 复制目录<br>cp -rf 参数f是删除已经存在的目标文件而不提示<br>cp -i 参数i和f相反，在覆盖目标文件之前将给出提示要求用户确认，回答y时目标文件将被覆盖，是交互式拷贝.</p><h4 id="5-删除文件和目录-删除文件或目录都可以用rm搞定"><a href="#5-删除文件和目录-删除文件或目录都可以用rm搞定" class="headerlink" title="5. 删除文件和目录(删除文件或目录都可以用rm搞定)"></a>5. 删除文件和目录(删除文件或目录都可以用rm搞定)</h4><p>rm 1.c //将1.c这个文件删除<br>rm -rf (强制删除文件或目录,删除时不提示.)</p><h4 id="6-移走目录或者改文件名"><a href="#6-移走目录或者改文件名" class="headerlink" title="6. 移走目录或者改文件名"></a>6. 移走目录或者改文件名</h4><p>mv [opitons] 源文件或目录 目标文件或目录<br>[options]主要参数<br>-i:交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答“y”或“n”，<br>这样可以避免误覆盖文件.<br>-f:禁止交互操作。mv操作要覆盖某个已有的目标文件时不给任何指示，指定此参数后i参数将不再起作用。<br>mv hello ../ 将hello目录或者文件移动上一级.</p><h4 id="7-alias-别名"><a href="#7-alias-别名" class="headerlink" title="7. alias 别名"></a>7. alias 别名</h4><p>alias dir=’ls -l’ 输入dir，其实就相当于执行了ls -l</p><h4 id="8-改变当前目录"><a href="#8-改变当前目录" class="headerlink" title="8. 改变当前目录"></a>8. 改变当前目录</h4><p>cd filename 进入 filename 这个目录<br>cd 退出当前目录<br>cd ../ 进入上一级目录.<br>cd - 返回上一次目录<br>cd ~ 返回主目录</p><h4 id="9-cat-more-less-命令"><a href="#9-cat-more-less-命令" class="headerlink" title="9. cat,more,less 命令"></a>9. cat,more,less 命令</h4><p>将某个文件的内容显示出来，<br>三个命令不同的是:cat 把文件内容一直打印出来，而more则分展显示，less 可以上下翻滚查看内容.<br>cat &gt; 1.txt 可以填写或者复制内容,按ctrl+d保存<br>cat 1.c<br>more 1.c<br>head -n filename 显示第N行的内容<br>tail -n filename 显示后N行的内容<br>tail -n /var/log/message 显示最新的20行日志</p><p>未完待续。。。<br><a href="https://zhuanlan.zhihu.com/p/24953800" target="_blank" rel="noopener">参考网址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Linux_01.png&quot; alt=&quot;img_1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、基本命令&quot;&gt;&lt;a href=&quot;#一、基本命令&quot; class=&quot;headerlink&quot; title=&quot;一、基本命令&quot;&gt;&lt;/a&gt;一、基本命令&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
      <category term="日常学习记录" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>WSL安装</title>
    <link href="http://yoursite.com/2020/06/06/WSL%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/06/06/WSL%E5%AE%89%E8%A3%85/</id>
    <published>2020-06-06T05:57:07.000Z</published>
    <updated>2020-06-14T12:33:10.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、开启WSL"><a href="#一、开启WSL" class="headerlink" title="一、开启WSL"></a>一、开启WSL</h2><p>在 <strong>控制面板</strong>-&gt;<strong>程序</strong>-&gt;<strong>程序和功能</strong> 中点击 <strong>启动或关闭Windows</strong>功能如图</p><p><img src="/images/WSL_01.png" alt="WSL_01"></p><p>勾选 <strong>适用于Linux的Windows子系统</strong></p><p><img src="/images/WSL_02.png" alt="WSL_01"></p><h2 id="二、安装linux"><a href="#二、安装linux" class="headerlink" title="二、安装linux"></a>二、安装linux</h2><h3 id="一、直接安装应用商店的Ubuntu"><a href="#一、直接安装应用商店的Ubuntu" class="headerlink" title="一、直接安装应用商店的Ubuntu"></a>一、直接安装应用商店的Ubuntu</h3><p>在应用商店搜索linux，选择合适的版本下载即可</p><p>（比较简单,不过貌似是只有Ubuntu，而且安装位置不能自己选择）</p><p><img src="/images/WSL_03.png" alt="WSL_02"></p><h3 id="二、使用LxRunOffline安装"><a href="#二、使用LxRunOffline安装" class="headerlink" title="二、使用LxRunOffline安装"></a>二、使用LxRunOffline安装</h3><h4 id="一、下载LXRunOffline"><a href="#一、下载LXRunOffline" class="headerlink" title="一、下载LXRunOffline"></a>一、下载LXRunOffline</h4><p><a href="/download/LxRunOffline-v3.4.0.zip">LxRunOffline-v3.4.0.zip</a></p><p>新建文件夹LXRunOffline，下载减压到该文件夹下</p><p>LXRunOffline的方便之处：</p><ul><li>Install any Linux distro to any directory on your computer.</li><li>Move an existing installation to another directory.</li><li>Duplicate(copy) an existing installation.</li><li>Register an existing installation directory. This enables you to install to a USB stick and use it on different computers.</li><li>Run arbitrary Linux commands in a specified installation.</li><li>Configure default user, environment variables and various flags.</li><li>Export configuration to an XML file and import from the file.</li><li>Export an installation to a tar file.</li></ul><h4 id="二、下载Linux镜像文件"><a href="#二、下载Linux镜像文件" class="headerlink" title="二、下载Linux镜像文件"></a>二、下载Linux镜像文件</h4><p><a href="/download/CentOS7.zip">CentOS7.zip</a></p><p>这个是CentOS7的镜像文件，也可以自己找其他镜像文件</p><h4 id="三、使用LXRunOffline部署Linux到WSL"><a href="#三、使用LXRunOffline部署Linux到WSL" class="headerlink" title="三、使用LXRunOffline部署Linux到WSL"></a>三、使用LXRunOffline部署Linux到WSL</h4><p>使用管理员权限打开cmd，cd到刚刚减压LXRunOffline的文件夹，执行下面的命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LxRunOffline.exe  install -n centos -d E:\ProgramData\Microsoft\Windows\WSL\CentOS -f  E:\Progra</span><br><span class="line">mData\Microsoft\Windows\WSL\centos<span class="number">-7</span>-docker.tar.xz</span><br></pre></td></tr></table></figure><p>其中 -d 后面是要安装到的目录，-f 是前面下载的镜像， -n 用来指定名称。</p><h4 id="四、启动linux"><a href="#四、启动linux" class="headerlink" title="四、启动linux"></a>四、启动linux</h4><p>然后使用  LxRunOffine 来开启 Centos</p><p>执行 <code>LxRunOffline  run  -n centos</code> </p><p>如果想在任何位置使用LXRunOffline，只需要把该文件夹加入环境变量就行。</p><p>参考<a href="https://blog.csdn.net/qq_18286031/article/details/102931794" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、开启WSL&quot;&gt;&lt;a href=&quot;#一、开启WSL&quot; class=&quot;headerlink&quot; title=&quot;一、开启WSL&quot;&gt;&lt;/a&gt;一、开启WSL&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;控制面板&lt;/strong&gt;-&amp;gt;&lt;strong&gt;程序&lt;/strong&gt;-&amp;g
      
    
    </summary>
    
    
      <category term="日常学习记录" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
