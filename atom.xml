<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alert Wang&#39;s blog</title>
  
  <subtitle>学习+记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-25T07:30:28.124Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alert Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>监督学习</title>
    <link href="http://yoursite.com/2020/07/23/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/23/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-23T08:39:27.000Z</published>
    <updated>2020-09-25T07:30:28.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><p>从给定的训练数据集中学习出一个函数（模型参数），当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求包括输入输出，也可以说是特征和目标。训练集中的目标是由人标注的。监督学习就是最常见的分类（注意和聚类区分）问题，通过已有的训练样本（即已知数据及其对应的输出）去训练得到一个最优模型（这个模型属于某个函数的集合，最优表示某个评价准则下是最佳的），再利用这个模型将所有的输入映射为相应的输出，对输出进行简单的判断从而实现分类的目的。也就具有了对未知数据分类的能力。监督学习的目标往往是让计算机去学习我们已经创建好的分类系统（模型）。<br />监督学习是训练神经网络和决策树的常见技术。这两种技术高度依赖事先确定的分类系统给出的信息，对于神经网络，分类系统利用信息判断网络的错误，然后不断调整网络参数。对于决策树，分类系统用它来判断哪些属性提供了最多的信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/517705/1600739844037-190aab93-967c-4723-b97b-ccb6e93cf3aa.jpeg#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=720&size=0&status=done&style=none&width=720" alt=""><br><a name="JCjhd"></a></p><h2 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h2><p><a name="71MOg"></a></p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p><a name="ZtX4i"></a></p><h3 id="高斯贝叶斯"><a href="#高斯贝叶斯" class="headerlink" title="高斯贝叶斯"></a>高斯贝叶斯</h3><p><a name="Vl1F7"></a></p><h3 id="多项朴素贝叶斯"><a href="#多项朴素贝叶斯" class="headerlink" title="多项朴素贝叶斯"></a>多项朴素贝叶斯</h3><p><a name="bsXlu"></a></p><h3 id="伯努利贝叶斯"><a href="#伯努利贝叶斯" class="headerlink" title="伯努利贝叶斯"></a>伯努利贝叶斯</h3><p><a name="JN7dM"></a></p><h3 id="平均-依赖性评估"><a href="#平均-依赖性评估" class="headerlink" title="平均-依赖性评估"></a>平均-依赖性评估</h3><p><a name="JiINf"></a></p><h3 id="贝叶斯信念网络"><a href="#贝叶斯信念网络" class="headerlink" title="贝叶斯信念网络"></a>贝叶斯信念网络</h3><p><a name="r4AYN"></a></p><h3 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h3><p><a name="9bFRl"></a></p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><a name="ARLHE"></a></p><h3 id="分类和回归树（CART）"><a href="#分类和回归树（CART）" class="headerlink" title="分类和回归树（CART）"></a>分类和回归树（CART）</h3><p><a name="6Bvaw"></a></p><h3 id="迭代Dichotomiser3（ID3）"><a href="#迭代Dichotomiser3（ID3）" class="headerlink" title="迭代Dichotomiser3（ID3）"></a>迭代Dichotomiser3（ID3）</h3><p><a name="ni4EM"></a></p><h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p><a name="bV1uc"></a></p><h3 id="C5-0算法"><a href="#C5-0算法" class="headerlink" title="C5.0算法"></a>C5.0算法</h3><p><a name="5bGD0"></a></p><h3 id="卡方自动交互检测（CHAID）"><a href="#卡方自动交互检测（CHAID）" class="headerlink" title="卡方自动交互检测（CHAID）"></a>卡方自动交互检测（CHAID）</h3><p><a name="PyPN0"></a></p><h3 id="决策残端"><a href="#决策残端" class="headerlink" title="决策残端"></a>决策残端</h3><p><a name="IkOrE"></a></p><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p><a name="iaAzy"></a></p><h3 id="SLIQ"><a href="#SLIQ" class="headerlink" title="SLIQ"></a>SLIQ</h3><p><a name="GLkb1"></a></p><h2 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h2><p><a name="bOm3e"></a></p><h3 id="Fisher线性判别"><a href="#Fisher线性判别" class="headerlink" title="Fisher线性判别"></a>Fisher线性判别</h3><p><a name="R7RTd"></a></p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p><br /><strong>线性回归模型：</strong><br /><strong><br />$h_\theta(x)=\theta_0+\theta_1 x_1 \tag{1}$<br /></strong>代价函数：<br /><br /><strong>$J(\theta_0,\theta_1)=\frac{1}{2m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^i)^2\tag{2}$</strong></p><p>我们的目的是将梯度下降算法应用到线性回归中，最小化$J(\theta_0,\theta_1)$。<br />关键在于确定$\frac{\partial}{\partial \theta_j}J(\theta_0,\theta_1)<br>$<br />推导</p><p>$\begin{align}<br>\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)&amp;=\frac{\partial}{\partial\theta_j}\frac{1}{2m}\sum ^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})^2\&amp;=\frac{\partial}{\partial\theta_j}\frac{1}{2m}\sum ^m_{i=1}(\theta_0+\theta_1x^{(i)}-y^{(i)})^2<br>\end{align}\tag{3}$</p><p>当j=0时</p><p>$\begin{align}<br>\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)&amp;=\frac{1}{m}\sum ^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})<br>\end{align}\tag{4}$</p><p>当j=1时<br /><br><br />$\begin{align}<br>\frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)&amp;=\frac{1}{m}\sum ^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}<br>\end{align}\tag{5}$<br /><br><br /><br><br />现在梯度下降算法就可以表示为<br />重复直到收敛<br /><br><br />$\begin{align}<br>&amp;\theta_0:=\theta_0-\alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})\<br>&amp;\theta_1:=\theta_1-\alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}<br>\end{align}\tag{6}$<br /><br><br />下面时梯度下降的示意图<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/517705/1600782955679-55c96689-f346-4b8d-8060-d2f7daf1b17b.jpeg#align=left&display=inline&height=246&margin=%5Bobject%20Object%5D&originHeight=849&originWidth=1582&size=0&status=done&style=none&width=458" alt=""><br /><strong>梯度下降算法会根据不同初始点的选取陷入不同的局部最小。但是就线性回归问题而言，它的代价函数的图形总是凸面函数。</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/517705/1600782955564-7967949b-68f1-4e24-9c80-189c6e24fd72.jpeg#align=left&display=inline&height=305&margin=%5Bobject%20Object%5D&originHeight=930&originWidth=1343&size=0&status=done&style=none&width=440" alt=""><br /><br><br />算法<br /><br><br />$\begin{align}<br>&amp;temp0:=\theta_0-\alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})\<br>&amp;temp1:=\theta_1-\alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\<br>&amp;\theta_0:=temp0\<br>&amp;\theta_1:=temp1\<br>\end{align}\tag{7}$<br /><br><br />下面这种算法是错误的，这样在计算$$\theta_1$$时$$\theta_0$$已经更新，不能实现同步更新。<br /><br><br />$\begin{align}<br>&amp;temp0:=\theta_0-\alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})\<br>&amp;\theta_0:=temp0\<br>&amp;temp1:=\theta_1-\alpha \frac{1}{m}\sum^m_{i=1}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\<br>&amp;\theta_1:=temp1\<br>\end{align}\tag{X}$<br /></p><p><a name="DIN59"></a></p><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p><a name="biSgP"></a></p><h3 id="多项逻辑回归"><a href="#多项逻辑回归" class="headerlink" title="多项逻辑回归"></a>多项逻辑回归</h3><p><a name="JrZ2d"></a></p><h3 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h3><p><a name="5hF71"></a></p><h3 id="感知"><a href="#感知" class="headerlink" title="感知"></a>感知</h3><p><a name="HETAa"></a></p><h3 id="支持向量机（SVM）"><a href="#支持向量机（SVM）" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h3><p><a name="6ycnu"></a></p><h2 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h2><p><a name="rfLbT"></a></p><h3 id="自动编码器"><a href="#自动编码器" class="headerlink" title="自动编码器"></a>自动编码器</h3><p><a name="7A35j"></a></p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p><a name="ZrlMB"></a></p><h3 id="玻尔兹曼机"><a href="#玻尔兹曼机" class="headerlink" title="玻尔兹曼机"></a>玻尔兹曼机</h3><p><a name="0jTJ2"></a></p><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><p><a name="sr802"></a></p><h3 id="Hopfield网络"><a href="#Hopfield网络" class="headerlink" title="Hopfield网络"></a>Hopfield网络</h3><p><a name="pBJ4e"></a></p><h3 id="多层感知器"><a href="#多层感知器" class="headerlink" title="多层感知器"></a>多层感知器</h3><p><a name="0qNEn"></a></p><h3 id="径向基函数网络（RBFN）"><a href="#径向基函数网络（RBFN）" class="headerlink" title="径向基函数网络（RBFN）"></a>径向基函数网络（RBFN）</h3><p><a name="1nRAL"></a></p><h3 id="受限玻尔兹曼机"><a href="#受限玻尔兹曼机" class="headerlink" title="受限玻尔兹曼机"></a>受限玻尔兹曼机</h3><p><a name="9gGKG"></a></p><h3 id="回归神经网络（RNN）"><a href="#回归神经网络（RNN）" class="headerlink" title="回归神经网络（RNN）"></a>回归神经网络（RNN）</h3><p><a name="gGkdI"></a></p><h3 id="自组织映射（SOM）"><a href="#自组织映射（SOM）" class="headerlink" title="自组织映射（SOM）"></a>自组织映射（SOM）</h3><p><a name="UqpKl"></a></p><h3 id="尖峰神经网络"><a href="#尖峰神经网络" class="headerlink" title="尖峰神经网络"></a>尖峰神经网络</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监督学习&quot;&gt;&lt;a href=&quot;#监督学习&quot; class=&quot;headerlink&quot; title=&quot;监督学习&quot;&gt;&lt;/a&gt;监督学习&lt;/h1&gt;&lt;p&gt;从给定的训练数据集中学习出一个函数（模型参数），当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求包括输入输出
      
    
    </summary>
    
    
      <category term="日常学习" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://yoursite.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yoursite.com/2020/07/23/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/07/23/python%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-23T08:33:17.000Z</published>
    <updated>2020-07-23T08:36:18.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><p><a name="tIeuf"></a></p><h3 id="NumPy-Ndarray对象"><a href="#NumPy-Ndarray对象" class="headerlink" title="NumPy Ndarray对象"></a>NumPy Ndarray对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数说明</th><th></th></tr></thead><tbody><tr><td align="center">名称</td><td>描述</td></tr><tr><td align="center">object</td><td>数组或嵌套的数列</td></tr><tr><td align="center">dtype</td><td>数组元素的数据类型，可选</td></tr><tr><td align="center">copy</td><td>对象是否需要复制，可选</td></tr><tr><td align="center">order</td><td>创建数组的样式，C为行方向，F为列方向，A为默认方向</td></tr><tr><td align="center">subok</td><td>默认返回一个与基类类型一致的数组</td></tr><tr><td align="center">ndmin</td><td>指定生成数组的最小维度</td></tr></tbody></table><p><a name="ZlCF0"></a></p><h3 id="NumPy数据类型"><a href="#NumPy数据类型" class="headerlink" title="NumPy数据类型"></a>NumPy数据类型</h3><table><thead><tr><th>bool_</th><th>布尔型数据类型（True 或者 False）</th></tr></thead><tbody><tr><td>int_</td><td>默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td></tr><tr><td>intc</td><td>与 C 的 int 类型一样，一般是 int32 或 int 64</td></tr><tr><td>intp</td><td>用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td></tr><tr><td>int8</td><td>字节（-128 to 127）</td></tr><tr><td>int16</td><td>整数（-32768 to 32767）</td></tr><tr><td>int32</td><td>整数（-2147483648 to 2147483647）</td></tr><tr><td>int64</td><td>整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td>uint8</td><td>无符号整数（0 to 255）</td></tr><tr><td>uint16</td><td>无符号整数（0 to 65535）</td></tr><tr><td>uint32</td><td>无符号整数（0 to 4294967295）</td></tr><tr><td>uint64</td><td>无符号整数（0 to 18446744073709551615）</td></tr><tr><td>float_</td><td>float64 类型的简写</td></tr><tr><td>float16</td><td>半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td>float32</td><td>单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td>float64</td><td>双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td>complex_</td><td>complex128 类型的简写，即 128 位复数</td></tr><tr><td>complex64</td><td>复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td>complex128</td><td>复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><p><a name="LBPIn"></a></p><h3 id="数据类型对象"><a href="#数据类型对象" class="headerlink" title="数据类型对象"></a>数据类型对象</h3><p><br />数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：<br /></p><ul><li>数据的类型（整数，浮点数或者 Python 对象）</li><li>数据的大小（例如， 整数使用多少个字节存储）</li><li>数据的字节顺序（小端法或大端法）</li><li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li><li>如果数据类型是子数组，它的形状和数据类型</li></ul><p>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。<br /><br><br />dtype 对象是使用以下语法构造的：<br /><code>numpy.dtype(object, align, copy)</code><br />object - 要转换为的数据类型对象<br />align - 如果为 true，填充字段使其类似 C 的结构体。<br />copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用<br /><br><br />每个内建类型都有一个唯一定义它的字符代码，如下：</p><table><thead><tr><th align="left">字符</th><th align="left">对应类型</th></tr></thead><tbody><tr><td align="left">b</td><td align="left">布尔型</td></tr><tr><td align="left">i</td><td align="left">(有符号) 整型</td></tr><tr><td align="left">u</td><td align="left">无符号整型 integer</td></tr><tr><td align="left">f</td><td align="left">浮点型</td></tr><tr><td align="left">c</td><td align="left">复数浮点型</td></tr><tr><td align="left">m</td><td align="left">timedelta（时间间隔）</td></tr><tr><td align="left">M</td><td align="left">datetime（日期时间）</td></tr><tr><td align="left">O</td><td align="left">(Python) 对象</td></tr><tr><td align="left">S, a</td><td align="left">(byte-)字符串</td></tr><tr><td align="left">U</td><td align="left">Unicode</td></tr><tr><td align="left">V</td><td align="left">原始数据 (void)</td></tr></tbody></table><p><a name="iYMpk"></a></p><h3 id="NumPy数组"><a href="#NumPy数组" class="headerlink" title="NumPy数组"></a>NumPy数组</h3><p>NumPy 的数组中比较重要 ndarray 对象属性</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n 行 m 列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于 .shape 中 n*m 的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">ndarray 对象的元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">ndarray 对象中每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">ndarray 对象的内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">ndarray元素的实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">ndarray 元素的虚部</td></tr><tr><td align="left">ndarray.data</td><td align="left">包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。</td></tr></tbody></table><p><br />数组创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype = float, order = <span class="string">'C'</span>)<span class="comment"># 数组元素随机</span></span><br><span class="line">numpy.zeros(shape, dtype = float, order = <span class="string">'C'</span>)<span class="comment"># 数组元素以0填充</span></span><br><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">'C'</span>)<span class="comment"># 数组元素以1填充</span></span><br><span class="line">numpy.asarray(a, dtype = <span class="literal">None</span>, order = <span class="literal">None</span>)<span class="comment"># 从已有数组创建</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">shape</td><td align="left">数组形状</td></tr><tr><td align="left">dtype</td><td align="left">数据类型，可选</td></tr><tr><td align="left">order</td><td align="left">有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td></tr><tr><td align="left">a</td><td align="left">任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.frombuffer(buffer, dtype = float, count = <span class="number">-1</span>, offset = <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 用于实现动态数组,接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">buffer</td><td align="left">可以是任意对象，会以流的形式读入。</td></tr><tr><td align="left">dtype</td><td align="left">返回数组的数据类型，可选</td></tr><tr><td align="left">count</td><td align="left">读取的数据数量，默认为-1，读取所有数据。</td></tr><tr><td align="left">offset</td><td align="left">读取的起始位置，默认为0。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange(start, stop, step, dtype)</span><br><span class="line"><span class="comment"># 根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。</span></span><br></pre></td></tr></table></figure><p><a name="rCN3V"></a></p><h3 id="NumPy切片和索引"><a href="#NumPy切片和索引" class="headerlink" title="NumPy切片和索引"></a>NumPy切片和索引</h3><br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 从索引 2 开始到索引 7 停止，间隔为2</span></span><br><span class="line">s = slice(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 也可以通过冒号分隔切片参数 start:stop:step 来进行切片操作</span></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> (a[s])</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果为</span><br><span class="line">[<span class="number">2</span>  <span class="number">4</span>  <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 冒号的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。</span></span><br><span class="line"><span class="comment"># 如果为 [2:]，表示从该索引开始以后的所有项都将被提取。</span></span><br><span class="line"><span class="comment"># 如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项。</span></span><br></pre></td></tr></table></figure><p>切片还可以包括省略号 <strong>…</strong>，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="keyword">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="keyword">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="keyword">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[[<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">5</span> <span class="number">6</span>]]</span><br></pre></td></tr></table></figure><p><a name="K5pZK"></a></p><h3 id="NumPy迭代数组"><a href="#NumPy迭代数组" class="headerlink" title="NumPy迭代数组"></a>NumPy迭代数组</h3><p>NumPy 迭代器对象 <strong>numpy.nditer</strong> 提供了一种灵活访问一个或者多个数组元素的方式。<br />迭代器最基本的任务的可以完成对数组元素的访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'原始数组是：'</span>)</span><br><span class="line"><span class="keyword">print</span> (a)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'迭代输出元素：'</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a):</span><br><span class="line">    <span class="keyword">print</span> (x, end=<span class="string">", "</span> )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">原始数组是：</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">迭代输出元素：</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br></pre></td></tr></table></figure><p>控制遍历顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, order=<span class="string">'F'</span>):</span><br><span class="line"><span class="comment"># Fortran order，即是列序优先；</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a.T, order=<span class="string">'C'</span>):</span><br><span class="line"><span class="comment"># C order，即是行序优先；</span></span><br></pre></td></tr></table></figure><p>修改数组中元素的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">60</span>,<span class="number">5</span>) </span><br><span class="line">a = a.reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'原始数组是：'</span>)</span><br><span class="line"><span class="keyword">print</span> (a)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> np.nditer(a, op_flags=[<span class="string">'readwrite'</span>]): </span><br><span class="line">    x[...]=<span class="number">2</span>*x </span><br><span class="line"><span class="keyword">print</span> (<span class="string">'修改后的数组是：'</span>)</span><br><span class="line"><span class="keyword">print</span> (a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">原始数组是：</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">5</span> <span class="number">10</span> <span class="number">15</span>]</span><br><span class="line"> [<span class="number">20</span> <span class="number">25</span> <span class="number">30</span> <span class="number">35</span>]</span><br><span class="line"> [<span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">55</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后的数组是：</span><br><span class="line">[[  <span class="number">0</span>  <span class="number">10</span>  <span class="number">20</span>  <span class="number">30</span>]</span><br><span class="line"> [ <span class="number">40</span>  <span class="number">50</span>  <span class="number">60</span>  <span class="number">70</span>]</span><br><span class="line"> [ <span class="number">80</span>  <span class="number">90</span> <span class="number">100</span> <span class="number">110</span>]]</span><br></pre></td></tr></table></figure><p><a name="O4npM"></a></p><h3 id="Numpy数组操作"><a href="#Numpy数组操作" class="headerlink" title="Numpy数组操作"></a>Numpy数组操作</h3><p><a name="hWyd0"></a></p><h4 id="修改数组形状"><a href="#修改数组形状" class="headerlink" title="修改数组形状"></a>修改数组形状</h4><p><strong>numpy.reshape</strong> 函数可以在不改变数据的条件下修改形状，格式如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.reshape(arr, newshape, order=<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure><ul><li>arr：要修改形状的数组</li><li>newshape：整数或者整数数组，新的形状应当兼容原有形状</li><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。</li></ul><p><strong>numpy.ndarray.flat</strong>是一个数组元素迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.flat:</span><br><span class="line">    <span class="keyword">print</span> (element)</span><br></pre></td></tr></table></figure><p>*<em>numpy.ndarray.flatten *</em>返回一份数组拷贝（展开），对拷贝所做的修改不会影响原始数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndarray.flatten(order=<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</li></ul><p>*<em>numpy.ravel *</em>展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ravel(a, order=<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。<br><a name="007UL"></a></li></ul><h4 id="翻转数组"><a href="#翻转数组" class="headerlink" title="翻转数组"></a>翻转数组</h4><p><strong>numpy.transpose</strong> 函数用于对换数组的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.transpose(arr, axes)</span><br></pre></td></tr></table></figure><ul><li>arr：要操作的数组</li><li>axes：整数列表，对应维度，通常所有维度都会对换。</li></ul><p>numpy.ndarray.T 类似 numpy.transpose<br /><strong>numpy.rollaxis</strong> 函数向后滚动特定的轴到一个特定位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.rollaxis(arr, axis, start)</span><br></pre></td></tr></table></figure><ul><li>arr：数组</li><li>axis：要向后滚动的轴，其它轴的相对位置不会改变</li><li>start：默认为零，表示完整的滚动。会滚动到特定位置。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;numpy&quot;&gt;&lt;a href=&quot;#numpy&quot; class=&quot;headerlink&quot; title=&quot;numpy&quot;&gt;&lt;/a&gt;numpy&lt;/h2&gt;&lt;p&gt;&lt;a name=&quot;tIeuf&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;NumPy-Ndarray对象&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="日常学习记录" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="ML" scheme="http://yoursite.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>Linux笔记</title>
    <link href="http://yoursite.com/2020/07/19/Linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/19/Linux%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-19T03:16:28.000Z</published>
    <updated>2020-07-20T16:08:31.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Linux系统的组成"><a href="#一、Linux系统的组成" class="headerlink" title="一、Linux系统的组成"></a>一、Linux系统的组成</h2><h3 id="1-内核"><a href="#1-内核" class="headerlink" title="1.内核"></a>1.内核</h3><p>​        内核是操作系统的核心，具有很多最基本的功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP/IP网络功能。</p><p>​        Linux内核的主要模块分为存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等几个部分，</p><h3 id="2-Shell"><a href="#2-Shell" class="headerlink" title="2.Shell"></a>2.Shell</h3><p>​        Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。</p><p>​        实际上，Shell是一个命令解释器，它解释由用户输入的命令并且将它们送到内核</p><p>​        另外，Shell编 程语言具有普通编程语言的很多特点，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。</p><h3 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h3><p>​        文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如xfs、ext4、ext3、ext2、msdos、vfat 和iso9660等。</p><h3 id="4-应用程序"><a href="#4-应用程序" class="headerlink" title="4.应用程序"></a>4.应用程序</h3><p>​        标准的Linux系统都有一套称为应用程序的程序集，它包括文本编辑器、编程语言、X Window、办公软件、影音软件、Internet工具和数据库等。</p><h2 id="二、安装Linux系统"><a href="#二、安装Linux系统" class="headerlink" title="二、安装Linux系统"></a>二、安装Linux系统</h2><h3 id="1-准备安装Linux系统"><a href="#1-准备安装Linux系统" class="headerlink" title="1.准备安装Linux系统"></a>1.准备安装Linux系统</h3><h3 id="2-安装Linux系统"><a href="#2-安装Linux系统" class="headerlink" title="2.安装Linux系统"></a>2.安装Linux系统</h3><h4 id="硬盘分区规划（1）"><a href="#硬盘分区规划（1）" class="headerlink" title="硬盘分区规划（1）"></a><strong>硬盘分区规划（1）</strong></h4><p>（1）最简单的分区规划</p><ul><li>swap分区：即交换分区，实现虚拟内存，建议大小是物理内存的1~2倍；</li><li>/boot分区：用来存放与Linux系统启动有关的程序，比如引导装载程序等，最少200MB；</li><li>/分区：建议大小至少在10GB以上。</li></ul><h4 id="硬盘分区规划（2）"><a href="#硬盘分区规划（2）" class="headerlink" title="硬盘分区规划（2）"></a><strong>硬盘分区规划（2）</strong></h4><p>（2）合理的分区规划</p><ul><li>swap分区：实现虚拟内存，建议大小是物理内存的1~2倍；</li><li>/boot分区：建议大小最少为200MB：</li><li>/usr分区：用来存放Linux系统中的应用程序，其相关数据较多，建议大小最少为8GB；</li><li>/var分区：用来存放Linux系统中经常变化的数据以及日志文件，建议大小最少为1GB；</li><li>/分区：Linux 系统的根目录，所有的目录都挂在这个目录下面，建议大小最少为1GB；</li><li>/home分区：存放普通用户的数据，是普通用户的宿主目录，建议大小为剩下的空间。</li></ul><h4 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a><strong>交换分区</strong></h4><ul><li>直接从物理内存读写数据要比从硬盘读写数据快的多，而物理内存是有限的，这样就使用到了虚拟内存。虚拟内存是为了满足物理内存的不足而提出的一.种策略，它是利用磁盘空间虚拟出的一-块逻辑内存，用作虚拟内存的磁盘空间被称为交换分区（swap分区）。</li><li>内核会将暂时不用的内存块信息写到交换分区，这样-来，物理内存得到了释放，这块内存就可以用于其它用途，当需要用到原始的内容时，这些信息会被重新从交换分区读入物理内存。</li><li>Linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</li></ul><h4 id="分区命名方案"><a href="#分区命名方案" class="headerlink" title="分区命名方案"></a><strong>分区命名方案</strong></h4><ul><li>Linux系统使用字母和数字的组合来指代硬盘分区，使用一种更加灵活的分区命名方案，该命名方案是基于文件的，文件名的格式为/dev/xxyN（比如/dev/sda1分区）。<ul><li>/dev：这是Linux系统中所有设备文件所在的目录名。因为分区位于硬盘上，而硬盘是设备，所以这些文件代表了在/dev_上所有可能的分区；</li><li>XX：分区名的前两个字母表示分区所在设备的类型，通常是hd（IDE硬盘）或sd（SCSI硬盘）。</li><li>y: 这个字母表示分区所在的设备。例如，/dev/hda（第1个IDE硬盘）或/dev/sdb（第2个SCSI硬盘）；</li><li>N：最后的数字N代表分区。前4个分区（主分区或扩展分区）用数字1~4表示，逻辑驱动器从5开始。例如，<br>/dev/hda3是第1个IDE硬盘上的第3个主分区或扩展分区；<br>/dev/sdb6是第2个SCSI硬盘上的第2个逻辑驱动器。</li></ul></li></ul><h3 id="3-注销、关闭和重启Linux系统"><a href="#3-注销、关闭和重启Linux系统" class="headerlink" title="3.注销、关闭和重启Linux系统"></a>3.注销、关闭和重启Linux系统</h3><h3 id="4-FirewallD防火墙"><a href="#4-FirewallD防火墙" class="headerlink" title="4.FirewallD防火墙"></a>4.FirewallD防火墙</h3><h2 id="三、字符界面操作基础"><a href="#三、字符界面操作基础" class="headerlink" title="三、字符界面操作基础"></a>三、字符界面操作基础</h2><h3 id="1-字符界面简介"><a href="#1-字符界面简介" class="headerlink" title="1.字符界面简介"></a>1.字符界面简介</h3><h4 id="进入Linux字符界面方式"><a href="#进入Linux字符界面方式" class="headerlink" title="进入Linux字符界面方式"></a><strong>进入Linux字符界面方式</strong></h4><ul><li>要进入Linux系统的字符界面可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入。</li></ul><h4 id="1、Linux字符界面"><a href="#1、Linux字符界面" class="headerlink" title="1、Linux字符界面"></a><strong>1、Linux字符界面</strong></h4><ul><li><p>安装Linux系统之后，系统启动默认进入的是图形化界面，可以通过使用以下命令修改为进入字符界面，所做改变在系统重新引导之后即可生效。<br><code>[root@rhel ~]#systemctl get-default</code> </p><p><code>graphical.target</code><br>//查看计算机系统启动后要进入的默认目标，graphical.target表示图形化界面<br><code>[root@rhel ~]#systemctl set-default multi-user.target</code><br>//将multi-user.target目标设置为启动计算机系统后要进入的默认目标，multi-user.target表示字符界面</p></li></ul><h4 id="2、字符界面登录提示"><a href="#2、字符界面登录提示" class="headerlink" title="2、字符界面登录提示"></a><strong>2、字符界面登录提示</strong></h4><ul><li>Linux系统用户登录分两步：第一步输入用户的用户名，系统根据该用户名识别用户；第二步输入用户的口令。当用户正确地输入用户名和口令后，就能合法地进入系统，这时就可以对系统进行各种操作了，注意：<br>超级用户root登录后提示符是”#”，而其他用户登录后提示符是”$”</li></ul><h4 id="3、图形界面下的终端"><a href="#3、图形界面下的终端" class="headerlink" title="3、图形界面下的终端"></a><strong>3、图形界面下的终端</strong></h4><h4 id="4、虚拟控制台"><a href="#4、虚拟控制台" class="headerlink" title="4、虚拟控制台"></a><strong>4、虚拟控制台</strong></h4><ul><li>Linux系统可以同时接受多个用户同时登录，还允许用户进行多次登录，这是因为Linux系统提供了虚拟控制台的访问方式。</li><li>在字符界面下，虚拟控制台的选择可以通过按下[Alt]键和一个功能键来实现，通常使用F1~F6键。比如用户登录后，按下[Alt+F2]键，用户可以看到“login：”提示符，说明用户进入了第二个虚拟控制台。然后只需按[Alt+F1]组合键，就可以回到第-一个虚拟控制台。</li><li>如果用户在图形界面下，那么可以使用[Ctrl+ Alt+F2]~[Ctrl+ Alt+F6]组合键切换字符虚拟控制台，使用[Ctrl+Alt+F1]可以切换到图形界面。</li></ul><h4 id="5、关闭和重启Linux系统"><a href="#5、关闭和重启Linux系统" class="headerlink" title="5、关闭和重启Linux系统"></a><strong>5、关闭和重启Linux系统</strong></h4><ul><li>在Linux系统中常用的关闭/重启系统的命令有shutdown、halt、reboot，每个命令的内部_工作过程是不同的。<ul><li><strong>shutdown命令</strong><br>shutdown命令可以安全地关闭或重启Linux系统。<br>命令语法：<br>shutdown[选项][时间][警告信息]<br>[例3.1]立即关闭计算机系统。<br><code>[root@rhel ~]#shutdown -h now</code><br>[例3.2]定时45分钟 后关闭计算机系统。<br><code>[root@rhel ~]#shutdown -h +45</code><br>[例3.3]立即重新启动计算机系统，并发出警告信息<br><code>[root@rhel ~]#shutdown -r now &quot;system will be reboot now.&quot;</code><br>[例3.4]定时在1 点38分重新启动计算机系统<br><code>[root@rhel ~]#shutdown -r 01:38</code></li><li><strong>halt命 令</strong><br>使用halt命令就是调用“shutdown-h”命令执行关机任务。<br>命令语法：halt[选项]<br>[例3.5]使用halt命 令关闭系统。<br><code>[root@rhel ~]# halt</code></li><li><strong>reboot命令</strong><br>reboot命令的工作过程与halt相似，不过reboot是引发计算机重启，而halt是引发计算机关闭。它的选项与halt相似。<br>[例3.6]使用reboot命 令重启计算机系统。<br><code>[root@rhel ~]# reboot</code></li></ul></li></ul><h4 id="6、目标"><a href="#6、目标" class="headerlink" title="6、目标"></a><strong>6、目标</strong></h4><ul><li>在RHEL7之前的版本，使用运行级别代表特定的操作模式。运行级别被定义为七个级别，用数字0到6表示，每个运行级别可以启动特定的一些服务。RHEL 7使用目标（target）替换运行级别。目标使用目标单元文件描述，目标单位文件扩展名是.target，目标单元文件的唯一目标，是将其他systemd单元文件通过一连串的依赖关系组织在一起。比如graphical.target单元，用于启动一个图形会话，systemd会启动像GNOME显示管理（gdm.service）、帐号服务（axxounts-daemon）这样的服务，并且会激活multi-user.target单元。相似的multi-user.target单元，会启动必不可少的NetworkManager service、dbus service服务，并激活basic.target单 元。</li><li>每一个目标都有名字和独特的功能，并且能够同时启用多个。一些目标继承其他目标的服务，并启动新服务。<br>systemd提供了一些模仿SystemVinit启动级别的目标，仍可以使用旧的telinit启动级别命令切换。</li><li>预定义目标和运行级别对应关系</li></ul><table><thead><tr><th>运行级别</th><th>目标</th><th>目标的链接文件</th><th>功能</th></tr></thead><tbody><tr><td>0</td><td>poweroff.target</td><td>runlevel0.target</td><td>关闭系统</td></tr><tr><td>1</td><td>rescue.target</td><td>runlevel1.target</td><td>进入救援模式</td></tr><tr><td>2</td><td>multi-user.target</td><td>runlevel2.target</td><td>进入非图形界面的多用户方式</td></tr><tr><td>3</td><td>multi-user.target</td><td>runlevel3.target</td><td>进入非图形界面的多用户方式</td></tr><tr><td>4</td><td>multi-user.target</td><td>runlevel4.target</td><td>进入非图形界面的多用户方式</td></tr><tr><td>5</td><td>graphical.target</td><td>runlevel5.target</td><td>进入图形界面的多用户方式</td></tr><tr><td>6</td><td>reboot.target</td><td>runlevel6.target</td><td>重启系统</td></tr></tbody></table><h3 id="2-在Linux系统下获取帮助"><a href="#2-在Linux系统下获取帮助" class="headerlink" title="2.在Linux系统下获取帮助"></a>2.在Linux系统下获取帮助</h3><ul><li><h4 id="使用man手册页"><a href="#使用man手册页" class="headerlink" title="使用man手册页"></a><strong>使用man手册页</strong></h4><ul><li>一般情况下，Linux系统中所有的资源都会随操作系统一起发行，包括内核源代码。而在线手册是操作系统所有资源的一本很好的使用手册。有不懂的命令时可以用man查看这个命令，写程序时有不会用的函数可以用man查看这个函数，有不懂的文件时也可以用man查看文件。</li><li>一般情况下man手册页的资源主要位于/usr/share/man目录下。</li></ul></li><li><p>man手册内/可以用于查询</p></li><li><h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a><strong>man命令</strong></h4><p>man命令格式化并显示在线的手册页。通常使用者只要在命令man后，输入想要获取的命令的名称，man就会列出一份完整的说明，其内容包括命令语法、各选项的意义以及相关命令等。<br>命令语法：man[选项][名称]</p></li><li><h4 id="man手册页类型"><a href="#man手册页类型" class="headerlink" title="man手册页类型"></a><strong>man手册页类型</strong></h4></li></ul><table><thead><tr><th align="center">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">用户命令</td></tr><tr><td align="center">2</td><td align="left">系统调用</td></tr><tr><td align="center">3</td><td align="left">C语言函数库</td></tr><tr><td align="center">4</td><td align="left">设备和特殊文件</td></tr><tr><td align="center">5</td><td align="left">文件格式和约定</td></tr><tr><td align="center">6</td><td align="left">游戏程序</td></tr><tr><td align="center">7</td><td align="left">杂记</td></tr><tr><td align="center">8</td><td align="left">系统管理工具</td></tr><tr><td align="center">9</td><td align="left">Linux内核API（内核调用）</td></tr></tbody></table><ul><li><h4 id="使用–help选项获取帮助"><a href="#使用–help选项获取帮助" class="headerlink" title="使用–help选项获取帮助"></a><strong>使用–help选项获取帮助</strong></h4><p>使用–help选项可以显示命令的使用方法以及命令选项的含义。只要在所需要显示的命令后面输入“–help”选项，然后就可以看到所查命令的帮助内容了。<br>命令语法：<br>[命令]–help.<br>[例3.9]查看mkdir命令的帮助信息。<br><code>[root@rhel ~]# mkdir --help</code></p></li></ul><h3 id="3-Shell基础"><a href="#3-Shell基础" class="headerlink" title="3.Shell基础"></a>3.Shell基础</h3><ul><li><p>Shell简介</p><ul><li>在AT&amp;T工作的Dennis Ritchie 和Ken Thompson两人在设计Unix操作系统的时候，想要为用户创建一种与Unix系统交流的方法。那时的操作系统带有命令解释器。命令解释器接受用户的命令，然后解释它们，因而计算机可以使用这些命令。</li><li>Ritchie和Thompson想要提供比当时的命令解释器具备更优异功能的工具。这导致了Bourne Shell（通称为sh）的开发，由S.R.Bourne创建。自从Bourne Shell出现以后，其它类型Shell也被一一开发，比如C Shell（csh）和Korn Shell（ksh）。</li><li>Shell接收用户命令，然后调用相应的应用程序，同时它还是一种程序设计语言，是系统管理维护时的重要工具。作为命令语言，它交互式的解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令。作为程序设计语言，它可以定义各种变量和参数，并提供了许多在高级语言中才具有的控制结构（循环和分支）。</li><li>Shell命令重新初始化用户的登录会话。当给出该命令时，就会重新设置进程的控制终端的端口特征，并取消对端口的所有访问。然后Shell命令为用户把进程凭证和环境重新设置为缺省值，并执行用户的初始程序。根据调用进程的登录用户标识建立所有的凭证和环境。</li><li>目前流行的Shell有sh、csh、ksh、tcsh 和bash等。大部分Linux系统的默认Shell类型为bash。</li></ul></li><li><p>bash简介</p><ul><li>bash（Bourne Again Shell）最早是在1987年由布莱恩.福克斯开发的一个为GNU计划编写的Unix Shell。bash目前是大多数Linux系统默认的Shell，它还能运行于大多数Unix风格的操作系统上。</li><li>bash的命令语法是Bourne shell命令语法的超集。数量庞大的Bourne shell脚本大多不经过修改就可以在bash中执行，只有那些引用了Bourne特殊变量或使用了Bourne内置命令的脚本才需要修改。bash的命令语法很多来自ksh和csh，比如命令行编辑、命令历史、目录栈、$RANDOM变量、$PPID变量以及POSIX命令置换语法。</li></ul></li><li><p>bash命令</p><ul><li>Linux系统的标准提示符包括了用户登录名、登录的主机名、当前所在的工作目录路径和提示符号。<br>以普通用户zhangsan登录名为rhel的主机，他的工作目录是/home/zhangsan，如下所示。<br><code>[zhangsan@rhel ~]$</code><br>以root用户登录系统的提示符如下所示。<br><code>[root@rhel ~]#</code></li></ul></li><li><p>Shell命令一般格 式</p><ul><li>要运行命令的话，只需要在提示符后敲进命令，然后再按“回车”键。<br>命令语法：<br>[Shell命令][选项][参数]</li><li>所有选项在该命令的man手册页中都有详细的介绍，而参数则由用户提供。选项决定命令如何工作，而参数则用于确定命令作用的目标。</li><li>选项有短命令行选项和长命令选项两种。</li></ul></li><li><p>Linux系统命令分类</p><ul><li>bash内置的命令<br>如果是bash内置的命令，则由bash负责回应。</li><li>应用程序<br>如果是应用程序，那么Shell会找出该应用程序，然后将控制权交给内核，由内核执行该应用程序，执行完之后，再将控制权交回给Shell。</li></ul></li></ul><h3 id="4-使用bash"><a href="#4-使用bash" class="headerlink" title="4.使用bash"></a>4.使用bash</h3><h4 id="1、常用控制组合键"><a href="#1、常用控制组合键" class="headerlink" title="1、常用控制组合键"></a><strong>1、常用控制组合键</strong></h4><table><thead><tr><th>控制组合键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+l</td><td>清屏</td></tr><tr><td>Ctrl+o</td><td>执行当前命令，并选择上一条命令</td></tr><tr><td>Ctrl+s</td><td>阻止屏幕输出</td></tr><tr><td>Ctrl+q</td><td>允许屏幕输出</td></tr><tr><td>Ctrl+c</td><td>终止命令</td></tr><tr><td>Ctrl+z</td><td>挂起命令</td></tr><tr><td>Ctrl+m</td><td>回车</td></tr><tr><td>Ctrl+d</td><td>输入结束，即EOF的意思，或者注销Linux系统</td></tr></tbody></table><h4 id="2、光标操作"><a href="#2、光标操作" class="headerlink" title="2、光标操作"></a><strong>2、光标操作</strong></h4><table><thead><tr><th>组合键</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl+a</td><td>移动光标到命令行首</td></tr><tr><td>Ctrl+e</td><td>移动光标到命令行尾</td></tr><tr><td>Ctrl+f</td><td>按字符前移（向右）</td></tr><tr><td>Ctrl+b</td><td>按字符后移（向左）</td></tr><tr><td>Ctrl+xx</td><td>在命令行首和光标之间移动</td></tr><tr><td>Ctrl+u</td><td>删除从光标到命令行首的部分</td></tr><tr><td>Ctrl+k</td><td>删除从光标到命令行尾的部分</td></tr><tr><td>Ctrl+w</td><td>删除从光标到当前单词开头的部分</td></tr><tr><td>Ctrl+d</td><td>删除光标处的字符</td></tr><tr><td>Ctrl+h</td><td>删除光标前的一个字符</td></tr><tr><td>Ctrl+y</td><td>插入最近删除的单词</td></tr><tr><td>Ctrl+t</td><td>交换光标处字符和光标前面的字符</td></tr><tr><td>Alt+f</td><td>按单词前移（向右）</td></tr><tr><td>Alt+b</td><td>按单词后移（向左）</td></tr><tr><td>Alt+d</td><td>从光标处删除至单词尾</td></tr><tr><td>Alt+c</td><td>从光标处更改单词为首字母大写</td></tr><tr><td>Alt+u</td><td>从光标处更改单词为全部大写</td></tr><tr><td>Alt+l</td><td>从光标处更改单词为全部小写</td></tr><tr><td>Alt+t</td><td>交换光标处单词和光标前面的单词</td></tr><tr><td>Alt+Backspace</td><td>与Ctrl+w功能类似，分隔符有些差别</td></tr></tbody></table><h4 id="3、特殊字符"><a href="#3、特殊字符" class="headerlink" title="3、特殊字符"></a><strong>3、特殊字符</strong></h4><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>~</td><td>用户主目录</td></tr><tr><td>`</td><td>反引号，用来命令替代</td></tr><tr><td>#</td><td>注释</td></tr><tr><td>$</td><td>变量取值</td></tr><tr><td>&amp;</td><td>后台进程工作</td></tr><tr><td>(</td><td>子Shell开始</td></tr><tr><td>)</td><td>子Shell结束</td></tr><tr><td>\</td><td>使命令持续到下一行</td></tr><tr><td>|</td><td>管道</td></tr><tr><td>&lt;</td><td>输入重定向</td></tr><tr><td>&gt;</td><td>输出重定向</td></tr><tr><td>&gt;&gt;</td><td>追加重定向</td></tr><tr><td>‘</td><td>单引号</td></tr><tr><td>“</td><td>双引号</td></tr><tr><td>/</td><td>路径分割符</td></tr><tr><td>;</td><td>命令分隔符</td></tr></tbody></table><h4 id="4、通配符"><a href="#4、通配符" class="headerlink" title="4、通配符"></a><strong>4、通配符</strong></h4><table><thead><tr><th>符号</th><th>功能</th></tr></thead><tbody><tr><td>？</td><td>代表任何单一字符</td></tr><tr><td>*</td><td>代表任何字符</td></tr><tr><td>[字符组合]</td><td>在中括号中的字符都符合，比如[a~z]代表所有的小写字母</td></tr><tr><td>[!字符组合]</td><td>不在中括号中的字符都符合，比如[!0-9]代表非数字的都符合</td></tr></tbody></table><h3 id="5-Shell实用功能"><a href="#5-Shell实用功能" class="headerlink" title="5.Shell实用功能"></a>5.Shell实用功能</h3><h4 id="1、命令行自动补全"><a href="#1、命令行自动补全" class="headerlink" title="1、命令行自动补全"></a><strong>1、命令行自动补全</strong></h4><ul><li><p>在Linux系统中，有太多的命令和文件名称需要记忆，使用命令行补全功能可以快速的写出文件名和命令名。<br>如果需要快速地从当前所在的目录跳转到<br>/usr/src/kernels/目录，可以执行以下操作。<br><code>[root@rhel ~]# cd /u&lt;Tab&gt;/sr&lt;Tab&gt;/k&lt;Tab&gt;</code></p><p><Tab>是按”Tab”键的意思，使用”Tab”键也称为命令行自动补全，这在平常应用中是不可缺少的</p></li></ul><h4 id="2、命令历史记录"><a href="#2、命令历史记录" class="headerlink" title="2、命令历史记录"></a><strong>2、命令历史记录</strong></h4><ul><li>在操作Linux系统的时候，每一个操作的命令都会记录到命令历史中，在以后可以通过命令历史查看和使用以前操作的命令。</li><li>bash启动的时候会读取~/.bash_history文件，并将其载入到内存中，$HISTFILE变量就用于设置~/.bash__history文件，bash退出时也会把内存中的历史记录回写到~/.bash_history文 件中。</li><li>使用history命令可以查看命令历史记录，每一条命令前面都会有一个序列号标示。<br>命令语法：history[选项]</li><li>Ctrl+R 使用历史记录中的命令</li></ul><h4 id="3、使用命令历史"><a href="#3、使用命令历史" class="headerlink" title="3、使用命令历史"></a><strong>3、使用命令历史</strong></h4><table><thead><tr><th>举例</th><th>描述</th></tr></thead><tbody><tr><td>!!</td><td>运行上一个命令</td></tr><tr><td>!6</td><td>运行第6个命合</td></tr><tr><td>!8/test</td><td>运行第8个命令并在命令后面加上/test</td></tr><tr><td>!?CF?</td><td>运行上一个包含CF字符串的命令</td></tr><tr><td>!ls</td><td>运行上一个Is命令（或以ls开头的历史命令）</td></tr><tr><td>!ls:s/CF/G</td><td>运行上一个Is命令，其中把CF替换成G</td></tr><tr><td>fc</td><td>编辑并运行上一个历史命令</td></tr><tr><td>fc 6</td><td>编辑并运行第6条历史命令</td></tr><tr><td>^boot^root^</td><td>快速替换。将最后一个命合中的boot替换为root后运行</td></tr><tr><td>!-5</td><td>运行倒数第5个命令</td></tr><tr><td>!$</td><td>运行前一个命令最后的参数</td></tr></tbody></table><p>[例3.11]使用命令历史记录功能键。<br><code>[root@rhel ~]# mkdir/root/aaa</code><br>//创建目录/root/aaa<br><code>[root@rhel ~]# cd !$</code><br><code>cd/root/aaa</code><br>//!$是指重复前一个命令最后的参数，参数是/root/aaa<br><code>[root@rhel aaa]# pwd</code><br><code>/root/aaa</code><br>//显示用户当前目录是/root/aaa</p><h4 id="4、搜索历史命令"><a href="#4、搜索历史命令" class="headerlink" title="4、搜索历史命令"></a><strong>4、搜索历史命令</strong></h4><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>↑</td><td>查看上一个命令</td></tr><tr><td>↓</td><td>查看下一个命令</td></tr><tr><td>Ctrl+p</td><td>查看历史列表中的上一个命令</td></tr><tr><td>Ctrl+n</td><td>查看历史列表中的下一个命令</td></tr><tr><td>Ctrl+r</td><td>向上搜索历史列表</td></tr><tr><td>Alt+p</td><td>向上搜索历史列表</td></tr><tr><td>Alt+&gt;</td><td>移动到历史列表末尾</td></tr></tbody></table><h4 id="5、命令排列"><a href="#5、命令排列" class="headerlink" title="5、命令排列"></a><strong>5、命令排列</strong></h4><ul><li><p>如果希望一次执行多个命令，Shell允许在不同的命令之间，放上特殊的排列字符。</p><ul><li><p>1.使用”;”<br>使用”;”命令时先执行命令1，不管命令1是否出错，接下来就执行命2。<br>命令语法：命令1;命令2</p></li><li><p>2.使用”&amp;&amp;”<br>使用”&amp;&amp;”命令时只有当命令1正确运行完毕后，才能执行命令2。<br>命令语法：命令1&amp;&amp;命令2</p></li></ul></li></ul><h4 id="6、命令替换"><a href="#6、命令替换" class="headerlink" title="6、命令替换"></a><strong>6、命令替换</strong></h4><ul><li>在Linux系统中，Shell命 令的参数可以由另外一个命令的结果来替代，这种称之为命令替换。<br>1.使用”$（）”<br>命令语法：命令1 $（命令2）<br>2.使用”`“<br>命令语法：命令1`命令2`</li></ul><h4 id="7、命令别名"><a href="#7、命令别名" class="headerlink" title="7、命令别名"></a><strong>7、命令别名</strong></h4><ul><li>在需要执行某-一个非常长的命令时，所有的命令以及命令的选项、参数都要一一输入，很枯燥也容易出现错误。可以为常用命令定义快捷方式，这些快捷方式可以用比较简单的命令别名来定义。<ul><li>1.创建别名.<br>使用alias命令可以为命令定义别名。如果命令中有空格的话，就需要使用双引号（比如在命令与选项之间就有空格）<br>命令语法：alias[别名]=[需要定义别名的命令]</li><li>2.取消别名<br>当用户需要取消别名的定义时，可以使用unalias命令。<br>命令语法：unalias[别名]</li></ul></li></ul><h4 id="8、管道"><a href="#8、管道" class="headerlink" title="8、管道"></a><strong>8、管道</strong></h4><ul><li>Linux系统的理念是汇集许多小程序，每个程序都有特殊的专长。复杂的任务不是由大型软件完成，而是运用Shell的机制，组合许多小程序共同完成。管道就在其中发挥着重要的作用，它可以将某个命令的输出信息当作某个命令的输入，由管道符号“|”来标识。<br>命令语法：<br>[命令1]|[命令2]|[命令3]<ul><li>[例3.22]<br>使用简单的管道。<br><code>[root@rhel ~]#Is/etc|more</code><br>abr<br>tacpi<br>adjtime<br>akonadi<br>–More–<br>//命令|s/etc显示/etc目录的内容，命令more是分页显示内容</li><li>[例3.23]<br>使用复杂的管道。<br><code>[root@PC-LINUX ~]#rpm -qa|grep a|more</code><br>//命令rpm-qa显示已经安装在系统上的RPM包，命令grepa是过滤软件包，命令more是分页显示这些信息</li></ul></li></ul><h3 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6.重定向"></a>6.重定向</h3><ul><li>希望将命令的输出结果保存到文件中，或者以文件内容作为命令的参数，这时就需要用到重定向。重定向不使用系统的标准输入端口、标准输出端口或是标准错误端口，而是进行重新的指定。</li><li>重定向有四种方式：输出重定向、输入重定向、错误重定向以及同时实现输出和错误的重定向。</li></ul><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a><strong>输出重定向</strong></h4><ul><li>输出重定向，即将某一命令执行的输出保存到文件中，如果已经存在相同的文件，那么覆盖源文件中的内容。命令语法：<br>[命令]&gt;[文件]<ul><li>[例3.24]使用输出重定向将/boot目录的内容保存到/root/abc文件中。<br><code>[root@rhel ~]#ls/boot &gt;/root/abc</code><br>[例3.25]使用echo命令和输出重定向创建/root/mm文件，文件内容是hello。<br><code>[root@rhel ~]#echo Hello &gt;/root/mm</code><br><code>[root@rhel ~]#cat/root/mm</code><br>Hello<br>//显示文件/root/mm，可以看到文件的内容是Hello</li></ul></li><li>另外一种特殊的输出重定向是输出追加重定向，即将某一命令执行的输出添加到已经存在的文件中。<br>命令语法：<br>[命令]&gt;&gt;[文件]<ul><li>[例3.26]使用输出追加重定向将数据写入文件/root/ao。<br><code>[root@rhel ~]#echo Hello &gt;/root/ao</code><br>//先创建文件/root/ao，文件内容是Hello<br><code>[root@rhel ~]#echo Linux &gt;&gt;/root/ao</code><br>//向文件/root/ao中追加数据Linux<br><code>[root@rhel ~]#cat/root/ao</code><br>Hello<br>Linux</li></ul></li></ul><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a><strong>输入重定向</strong></h4><ul><li><p>输入重定向，即将某一文件的内容作为命令的输入。<br>命令语法：<br>[命令]&lt;[文件]</p><ul><li>[例3.27]使用输入重定向将文件/root/mm的内容作为输入让cat命令执行。<br><code>[root@rhel ~]#cat &lt;/root/mm</code><br>Hello<br>//可以看到文件/root/mm的内容是Hello</li></ul></li><li><p>另外一种特殊的输入重定向是输入追加重定向，这种输入重定向告诉Shell，当前标准输入来自命令行的一对分隔符之间的内容。<br>命令语法：<br>[命令]&lt;&lt;[分隔符]<br>&gt;[文本内容]<br>&gt;[分隔符]</p><ul><li>[例3.28]使用输入追加重定向创建/root/bc文件。<br><code>[root@rhel ~]#cat &gt;/root/bc &lt;&lt;EOF</code><br><code>\&gt;Hello Linux</code><br><code>\&gt;EOF</code><br>//一般使用EOF作为分隔符</li></ul></li></ul><h4 id="错误重定向"><a href="#错误重定向" class="headerlink" title="错误重定向"></a><strong>错误重定向</strong></h4><ul><li>错误重定向，即将某一命令执行的出错信息输出到指定文件中。<br>命令语法：<br>[命令]2&gt;[文件]<ul><li>[例3.29]查看 根本不存在的/root/kk文件，出现报错信息，将其保存到文件/root/b中。<br><code>[root@rhel ~]#cat/root/kk 2&gt; /root/b</code><br><code>[root@rhel ~]#cat/root/b</code><br>cat：lrootlkk：没有那个文件或目录<br>//使用cat命令查看/root/b文件，可以看到其内容就是执行命令cat/root/kk的报错信息</li></ul></li><li>另外一种特殊的错误重定向是错误追加重定向，即将某一命令执行的出错信息添加到已经存在的文件中<br>命令语法：<br>[命令]2&gt;&gt;[文件]<ul><li>[例3.30]使用错误追加重定向，将执行命令的多次出错信息保存到文件/root/b中。<br><code>[root@rhel ~]#cat/root/kk 2&gt; /root/b</code><br><code>[root@rhel ~]#cat/root/kk 2&gt;&gt; /root/b</code><br><code>[root@rhel ~]#cat/root/b</code><br>cat：/root/kk：没有那个文件或目录cat：/root/kk：没有那个文件或目录</li></ul></li></ul><h4 id="同时实现输出和错误重定向"><a href="#同时实现输出和错误重定向" class="headerlink" title="同时实现输出和错误重定向"></a><strong>同时实现输出和错误重定向</strong></h4><ul><li>同时实现输出和错误的重定向，即可以同时实现输出重定向和错误重定向的功能。<br>命令语法：<br>[命令]&amp;&gt;[文件]<br>[例3.31]同时使用输出和错误重定向。<br><code>[root@rhel ~]#ls/boot &amp;&gt; /root/kk</code><br><code>[root@rhel ~]#cat/root/kk</code><br>config-3.3.4-5.fc17.i686.PAE<br>grub<br>grub2<br>initramfs-3.3.4-5.fc17.i686.PAE.img<br>lost+found<br>System.map-3.3.4-5.fc17.i686.PAE<br>tboot.gz<br>tboot-syms<br>vmlinuz-3.3.4-5.fc17.i686.PAE<br>//因为/boot目录下有文件，所以最终使用了输出重定向</li></ul><h3 id="7-vi编辑器"><a href="#7-vi编辑器" class="headerlink" title="7.vi编辑器"></a>7.vi编辑器</h3><ul><li>文本编辑器有很多，图形模式下有gedit，kwrite等编辑器，文本模式下的编辑器有vi，vim （vi的增强版本）和nano。</li><li>vi和vim是Linux系统中最常用的编辑器，本节主要讲述vi编辑器的使用。</li></ul><h4 id="vi编辑器简介"><a href="#vi编辑器简介" class="headerlink" title="vi编辑器简介"></a><strong>vi编辑器简介</strong></h4><ul><li>vi编辑器是Linux系统字符界面下最常使用的文本编辑器，用于编辑任何ASCII文本，对于编辑源程序尤其有用。vi编辑器功能非常强大，通过使用vi编辑器，可以对文本进行创建、查找、替换、删除、复制和粘贴等操作。</li><li>在Linux系统Shell提示符下输入vi和文件名称后，就进入vi编辑界面。如果系统内还不存在该文件，就意味着创建文件，如果系统内存在该文件，就意味着编辑该文件。</li><li>vi编辑器有3种基本工作模式，分别是命令模式、插入模式和末行模式。</li></ul><h4 id="1、命令模式"><a href="#1、命令模式" class="headerlink" title="1、命令模式"></a><strong>1、命令模式</strong></h4><ul><li>进入vi编辑器之后，系统默认处于命令模 式。命令模式控制屏幕光标的移动，字符、 字或行的删除，某区域的移动、复制等。 在命令模式下，按冒号键“:”可以进入末 行模式，按字母键“a”就可以进入插入模式。</li></ul><h4 id="2、插入模式"><a href="#2、插入模式" class="headerlink" title="2、插入模式"></a><strong>2、插入模式</strong></h4><ul><li>只有在插入模式下，才可以进行文本编辑。在插入模式下按“Esc”键可回到命令模式。</li></ul><h4 id="3、末行模式"><a href="#3、末行模式" class="headerlink" title="3、末行模式"></a><strong>3、末行模式</strong></h4><ul><li>将文件保存或退出vi编辑器，也可以设置 编辑环境、替换字符或删除字符。</li><li>在末行模式下按“Esc”键可以回到命令模式。</li></ul><h4 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a><strong>进入插入模式</strong></h4><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">i</td><td>从光标当前所在位置之前开始插入</td></tr><tr><td align="center">a</td><td>从光标当前所在位置之后开始插入</td></tr><tr><td align="center">I</td><td>在光标所在行的行首插入</td></tr><tr><td align="center">A</td><td>在光标所在行的行末尾插入</td></tr><tr><td align="center">o</td><td>在光标所在的行的下面新开一行插入</td></tr><tr><td align="center">O</td><td>在光标所在的行的上面新开一行插入</td></tr><tr><td align="center">s</td><td>在光标所在的行的上面新开一行插入</td></tr><tr><td align="center">S</td><td>删除光标所在的行，然后进入插入模式</td></tr></tbody></table><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a><strong>光标移动</strong></h4><table><thead><tr><th align="center">命令</th><th>功能</th></tr></thead><tbody><tr><td align="center">↑</td><td>使光标向上移动一行</td></tr><tr><td align="center">↓</td><td>使光标向下移动一行</td></tr><tr><td align="center">←</td><td>使光标向左移动一行</td></tr><tr><td align="center">→</td><td>使光标向右移动一行</td></tr><tr><td align="center">k</td><td>使光标向上移动一行</td></tr><tr><td align="center">j</td><td>使光标向下移动一行</td></tr><tr><td align="center">h</td><td>使光标向左移动一行</td></tr><tr><td align="center">l</td><td>使光标向右移动一行</td></tr><tr><td align="center">nk</td><td>使光标向上移动n行，n代表数字</td></tr><tr><td align="center">nj</td><td>使光标向下移动n行，n代表数字</td></tr><tr><td align="center">nh</td><td>使光标向左移动n个字符，n代表数字</td></tr><tr><td align="center">nl</td><td>使光标向右移动n个字符，n代表数字</td></tr><tr><td align="center">H</td><td>使光标移动到屏幕的顶部</td></tr><tr><td align="center">M</td><td>使光标移动到屏幕的中间</td></tr><tr><td align="center">L</td><td>使光标移动到屏幕的底部</td></tr><tr><td align="center">Ctrl+b</td><td>使光标往上移动一页屏幕</td></tr><tr><td align="center">Ctrl+f</td><td>使光标往下移动一页屏幕</td></tr><tr><td align="center">Ctrl+u</td><td>使光标往上移动半页屏幕</td></tr><tr><td align="center">Ctrl+d</td><td>使光标往下移动半页屏幕</td></tr><tr><td align="center">数字0</td><td>使光标移到所在行的行首</td></tr><tr><td align="center">$</td><td>使光标移动到光标所在行的行尾</td></tr><tr><td align="center">^</td><td>使光标移动到光标所在行的行首</td></tr><tr><td align="center">w</td><td>使光标跳到下一个字的开头</td></tr><tr><td align="center">W</td><td>使光标跳到下一个字的开头，但会忽略一些标点符号</td></tr><tr><td align="center">e</td><td>使光标跳到下一个字的字尾</td></tr><tr><td align="center">E</td><td>使光标跳到下一个字的字尾，但会忽略一些标点符号</td></tr><tr><td align="center">b</td><td>使光标回到上一个字的开头</td></tr><tr><td align="center">B</td><td>使光标回到上一个字的开头，但会忽略一些标点符号</td></tr><tr><td align="center">(</td><td>使光标移动到上一个句首</td></tr><tr><td align="center">)</td><td>使光标移动到下一个句首</td></tr><tr><td align="center">{</td><td>使光标移动到上一个段落首</td></tr><tr><td align="center">}</td><td>使光标移动到下一个段落首</td></tr><tr><td align="center">G</td><td>使光标移动到文件尾（最后一行的第一个非空白字符处）</td></tr><tr><td align="center">gg</td><td>使光标移动到文件首（第一行第一个非空白字符处）</td></tr><tr><td align="center">Ctrl+p</td><td>使光标向上移动一行</td></tr><tr><td align="center">Ctrl+n</td><td>使光标向下移动一行</td></tr><tr><td align="center">n|</td><td>使光标移动到第n个字符处，n代表数字</td></tr><tr><td align="center">nG</td><td>使光标移动到第n行首，n代表数字</td></tr><tr><td align="center">n+</td><td>使光标向下移动n行，n代表数字</td></tr><tr><td align="center">n-</td><td>使光标向上移动n行，n代表数字</td></tr><tr><td align="center">n$</td><td>使光标移动到以当前行算起的第n行尾，n代表数</td></tr></tbody></table><h4 id="命令模式命令"><a href="#命令模式命令" class="headerlink" title="命令模式命令"></a>命令模式命令</h4><table><thead><tr><th>类型</th><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>删除</td><td>x</td><td>删除光标所在位置的字符</td></tr><tr><td>删除</td><td>X</td><td>删除光标所在位置的前面一个字符</td></tr><tr><td>删除</td><td>nx</td><td>删除光标所在位置开始的n个字符，n代表数字</td></tr><tr><td>删除</td><td>nX</td><td>删除光标所在位置前面n个字符，n代表数字</td></tr><tr><td>删除</td><td>dd</td><td>删除光标所在行</td></tr><tr><td>删除</td><td>ndd</td><td>从光标所在行开始删除n行，n代表数字</td></tr><tr><td>删除</td><td>db</td><td>删除光标所在位置的前面一个单词</td></tr><tr><td>删除</td><td>ndb</td><td>删除光标所在位置的前面n个单词，n代表数字</td></tr><tr><td>删除</td><td>dw</td><td>从光标所在位置开始删除一个单词</td></tr><tr><td>删除</td><td>ndw</td><td>从光标所在位置开始删除几个单词，n代表数字</td></tr><tr><td>删除</td><td>d$</td><td>删除光标到行尾的内容（含光标所在处字符）</td></tr><tr><td>删除</td><td>D</td><td>删除光标到行尾的内容（含光标所在处字符）</td></tr><tr><td>删除</td><td>dG</td><td>从光标位置所在行一直删除到文件尾</td></tr><tr><td>复制和粘贴</td><td>yw</td><td>复制光标所在位置到单词尾的字符</td></tr><tr><td>复制和粘贴</td><td>nyw</td><td>复制光标所在位置开始的n个单词，n代表数字</td></tr><tr><td>复制和粘贴</td><td>yy</td><td>复制光标所在行</td></tr><tr><td>复制和粘贴</td><td>nyy</td><td>复制从光标所在行开始的n行，n代表数字</td></tr><tr><td>复制和粘贴</td><td>y$</td><td>将缓冲区内的内容写到光标所在的位置</td></tr><tr><td>复制和粘贴</td><td>y^</td><td>复制光标前面所在位置到行首内容到缓存区</td></tr><tr><td>复制和粘贴</td><td>YY</td><td>将当前行复制到缓冲区</td></tr><tr><td>复制和粘贴</td><td>nYY</td><td>将当前开始的n行复制到缓冲区，n代表数字</td></tr><tr><td>复制和粘贴</td><td>p</td><td>将缓冲区内的内容写到光标所在的位置</td></tr><tr><td>替换</td><td>r</td><td>替换光标所在处的字符，按[r]键之后输入要替换的字符</td></tr><tr><td>替换</td><td>R</td><td>替换光标所到之处的字符，直到按下[ESC]键为止，按[R]键之后输入要替换的字符</td></tr><tr><td>撤销和重复</td><td>u</td><td>撤销上一个操作。按多次u可以执行多次撤销</td></tr><tr><td>撤销和重复</td><td>U</td><td>取消所有操作</td></tr><tr><td>撤销和重复</td><td>.</td><td>再执行一次前面刚完成的操作</td></tr><tr><td>列出行号</td><td>Ctrl+g</td><td>列出光标所在行的行号</td></tr><tr><td>保存退出</td><td>ZZ</td><td>保存退出</td></tr><tr><td>保存退出</td><td>ZQ</td><td>不保存退出</td></tr><tr><td>查找</td><td>/</td><td>先按[/]键，再输入想查找的字符，如果第一次查找的关键字不是想要的，可以一直按[n]键会往后查找下一个关键字，而按[N]键会往相反的方向查找</td></tr><tr><td>查找</td><td>?</td><td>先按[?]键，再输入想查找的字符，如果第一.次查找的关键字不是想要的，可以一直按[n]键会往前查找下一个关键字，而按[N]键会往相反的方向查找</td></tr></tbody></table><hr><p>update: 2020-7-20 20:49:22</p><h2 id="四、目录和文件管理"><a href="#四、目录和文件管理" class="headerlink" title="四、目录和文件管理"></a>四、目录和文件管理</h2><pre><code>Linux系统与Windows系统有很大的不同， 它以目录的形式挂载文件系统，其目录结 构是一个分层的树形结构。链接是一种在 共享文件和访问它的用户的若干目录项之 间建立联系的方法，Linux系统中包括硬链接和软链接两种方式。</code></pre><h3 id="1-Linux文件类型"><a href="#1-Linux文件类型" class="headerlink" title="1.Linux文件类型"></a>1.Linux文件类型</h3><ul><li>在Linux系统中除了一般文件之外，所有的目录和设备（如光驱、硬盘等）都是以文 件的形式存在的。 Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。</li><li>通过一般应用程序创建的文件，比如file.txt、file.tar.gz，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多称之为普通文件。</li><li>Linux文件类型常见的有：普通文件、目录文件、设备文件（字符设备文件和块设备文件）、管道文件和符号链接文件等。</li></ul><h4 id="1-普通文件"><a href="#1-普通文件" class="headerlink" title="1.普通文件"></a>1.普通文件</h4><ul><li>用“ls -lh”命令查看某个文件的属性， 可以看到有类似“-rw——-”的属性符 号，其属性第一个符号是“-”，这样的文 件在Linux系统中就是普通文件。这些文件 一般是用一些相关的应用程序创建，比如<br>图像工具、文档工具或归档工具等。</li></ul><h4 id="2-目录文件"><a href="#2-目录文件" class="headerlink" title="2.目录文件"></a>2.目录文件</h4><ul><li>当在某个目录下执行“ls -lh”命令，看 到有类似“drwxr-xr-x”的属性符号，其 属性第一个符号是“d”，这样的文件在Linux系统中就是目录文件。</li></ul><h4 id="3-设备文件"><a href="#3-设备文件" class="headerlink" title="3.设备文件"></a>3.设备文件</h4><ul><li>Linux系统中的/dev目录中有大量的设备文 件，主要是块设备文件和字符设备文件。<ul><li>（1）块设备文件 块设备的主要特点是可以随机读写，而最 常见的块设备就是磁盘，如/dev/hda1、 /dev/sda1等。用“ls -l”命令查看某个文件的属性，可以看到有类似“brw-rw—”的属性符号，其属性第一个符号是 “b”，这样的文件在Linux系统中就是块设备文件。</li><li>（2）字符设备文件 最常见的字符设备文件是打印机和终端， 可以接收字符流。/dev/null是一个非常有 用的字符设备文件，送入这个设备的所有 内容都被忽略。用“ls -l”命令查看某个文件的属性，可以看到有类似“crw–w—”的属性符号，其属性第一个符号是 “c”，这样的文件在Linux系统中就是字符设备文件。</li></ul></li></ul><h4 id="4-管道文件"><a href="#4-管道文件" class="headerlink" title="4.管道文件"></a>4.管道文件</h4><ul><li>管道文件有时候也被叫做FIFO文件（FIFO 是先进先出的意思），管道文件就是从一 头流入，从另一头流出。用“ls -l”命令查看某个文件的属性，可以看到有类似 “prw——-”的属性符号，其属性第一 个符号是“p”，这样的文件在Linux系统中就是管道文件。</li></ul><h4 id="5-链接文件"><a href="#5-链接文件" class="headerlink" title="5.链接文件"></a>5.链接文件</h4><ul><li>链接文件有两种类型：软链接文件和硬链接文件。 <ul><li>（1）软链接文件<ul><li>软链接文件又叫符号链接文件，这个文件包含了另一个文 件的路径名。其可以是任意文件或目录，可以链接不同文 件系统的文件。在对软链接文件进行读写的时候，系统会 自动地把该操作转换为对源文件的操作，但删除软链接文 件时，系统仅仅删除软链接文件，而不删除源文件本身。</li><li>用“ls -l”命令查看某个文件的属性，可以看到有类似“lrwxrwxrwx”的属性符号，其属性第一个符号是“l”，这样的文件在Linux系统中就是软链接文件。</li></ul></li><li>（2）硬链接文件<ul><li>硬链接是已存在文件的另一个文件，对硬链接文件进行读写和删除操作时，结果和软链接相同。但如果删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了原有的 内容。这时，系统就“记”了它曾经是硬链接文件，而把它当成一个普通文件。</li><li>用“ls -l”命令查看某个文件的属性，可以看到第二列 的文件硬链接数大于1 ，这样的文件在Linux系统中就是硬链接文件。</li></ul></li></ul></li></ul><h3 id="2-Linux目录结构"><a href="#2-Linux目录结构" class="headerlink" title="2.Linux目录结构"></a>2.Linux目录结构</h3><ul><li>Linux系统都有根文件系统，它包含系统引 导和使其它文件系统得以挂载所必要的文 件，根文件系统需要有单用户状态所必须 的足够的内容，还应该包括修复损坏系统、 恢复备份等工具。</li><li>Linux系统的目录结构是分层的树形结构，<br>都是挂载在根文件系统“/”下。</li></ul><h4 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h4><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>/home</td><td>包含Linux系统上各用户的主目录，子目录名称默认以该用户 名命名</td></tr><tr><td>/root</td><td>是root用户的主目录</td></tr><tr><td>/bin</td><td>包含常用的命令文件，不能包含子目录</td></tr><tr><td>/sbin</td><td>包含系统管理员和root用户所使用的命令文件</td></tr><tr><td>/dev</td><td>包含大部分的设备文件，比如磁盘、光驱等</td></tr><tr><td>/lib</td><td>包含Linux系统的共享文件和内核模块文件 /lib/modules目录存放核心可加载模块</td></tr><tr><td>/lib64</td><td>包含64位版本Linux系统的共享文件和内核模块文件</td></tr><tr><td>/tmp</td><td>包含一些临时文件</td></tr><tr><td>/mnt</td><td>手动为某些设备（比如硬盘）挂载提供挂载目录</td></tr><tr><td>/boot</td><td>包含Linux系统的内核文件和引导装载程序（如GRUB）文件</td></tr><tr><td>/opt</td><td>包含某些第三方应用程序的安装文件</td></tr><tr><td>/media</td><td>由系统自动为某些设备（一般为光盘、U盘等设备）挂载提供挂载目录</td></tr><tr><td>/var</td><td>该目录存放不经常变化的数据，如系统日志、打印队列、DNS数据库文件等</td></tr><tr><td>/etc</td><td>包含Linux系统上大部分的配置文件，建议修改配置文件之前先备份</td></tr><tr><td>/usr</td><td>包含可以供所有用户使用的程序和数据</td></tr><tr><td>/srv</td><td>存储一些服务启动之后所需要取用的资料目录</td></tr><tr><td>/run</td><td>一个临时文件系统，一些程序或服务启动以后，会将他们的PID放置在该目录中</td></tr><tr><td>/sys</td><td>在Linux系统提供热插拔能力的同时，该目录包含所检测到的硬件设置，它们被 转换成/dev目录中的设备文件</td></tr><tr><td>/proc</td><td>是一个虚拟的文件系统，它不存在磁盘上，而是由内核在内存中产生， 用于提供系统的相关信息。 下面说明在/proc目录下的一些最重要的文件。<br/>/proc/cpuinfo：该文件保存计算机CPU信息。 <br/>/proc/filesystems：该文件保存Linux文件系统信息。 <br/>/proc/ioports：该文件保存计算机I/O端口号信息。 <br/>/proc/version：该文件保存Linux系统版本信息。<br/>/proc/meminfo：该文件保存计算机内存信息。</td></tr></tbody></table><h3 id="3-文件和目录操作"><a href="#3-文件和目录操作" class="headerlink" title="3.文件和目录操作"></a>3.文件和目录操作</h3><ul><li>本节主要讲述在Linux系统下如何使用命令 对文件和目录进行操作，涉及的命令有pwd、cd、ls、touch、mkdir、rmdir、cp、mv、rm、wc等。</li></ul><h4 id="pwd：显示工作目录路径"><a href="#pwd：显示工作目录路径" class="headerlink" title="pwd：显示工作目录路径"></a>pwd：显示工作目录路径</h4><ul><li>显示当前用户所处的工作目录的绝对路径。</li><li>命令语法： pwd [选项]<br>【例4.1】 显示用户当前工作目录路径。<br><code>[root@rhel sysconfig]# pwd</code><br>/etc/sysconfig<br>//用户当前工作目录路径是/etc/sysconfig</li></ul><h4 id="cd：更改工作目录路径"><a href="#cd：更改工作目录路径" class="headerlink" title="cd：更改工作目录路径"></a>cd：更改工作目录路径</h4><ul><li>更改用户的工作目录路径。工作目录路径 可以使用绝对路径名或相对路径名，绝对 路径从/（根）开始，然后循序到所需的目录下，相对路径从当前目录开始。</li><li>命令语法： cd [选项] [目录]<br>【例4.2】 更改用户工作目录路径为/etc。<br><code>[root@rhel sysconfig]# cd /etc</code><br><code>[root@rhel etc]# pwd</code><br>/etc<br>//查看当前目录，已经更改为/etc了<br>【例4.3】 更改目录位置至当前目录的父目录。<br><code>[root@rhel etc]# pwd</code><br>/etc<br><code>[root@rhel etc]# cd ..</code><br><code>[root@rhel /]# pwd</code><br>/<br>//可以看到目录已经更改为当前目录的父级目录“/”了<br>【例4.4】 更改目录位置为用户主目录。<br><code>[root@rhel /]# pwd</code><br><code>/</code><br><code>[root@rhel /]# cd ~</code><br><code>[root@rhel ~]# pwd</code><br><code>/root</code><br>//可以看到目录已经更改为当前用户的主目录<br>【例4.5】 更改目录位置至用户zhangsan的主目录。<br><code>[root@rhel ~]# cd ~zhangsan</code><br><code>[root@rhel zhangsan]# pwd</code><br><code>/home/zhangsan</code><br>//可以看到目录已经更改为用户zhangsan的主目录/home/zhangsan</li></ul><h4 id="ls：列出目录和文件信息"><a href="#ls：列出目录和文件信息" class="headerlink" title="ls：列出目录和文件信息"></a>ls：列出目录和文件信息</h4><ul><li>对于目录而言将列出其中的所有子目录与 文件信息；对于文件而言将输出其文件名 以及所要求的其它信息。</li><li>命令语法：ls [选项] [目录|文件]</li></ul><p><strong>ls命令显示的详细信息</strong></p><table><thead><tr><th align="center">列数</th><th>描述</th></tr></thead><tbody><tr><td align="center">1</td><td>第1个字符表示文件的类型 <br/>第2～4个字符表示文件的用户所有者对此文件的访问权限 <br/>第5～7个字符表示文件的组群所有者对此文件的访问权限<br/>第8～10个字符表示其他用户对此文件的访问权限</td></tr><tr><td align="center">2</td><td>文件的链接数</td></tr><tr><td align="center">3</td><td>文件的用户所有者</td></tr><tr><td align="center">4</td><td>文件的组群所有者</td></tr><tr><td align="center">5</td><td>文件长度（也就是文件大小，不是文件的磁盘占用量）</td></tr><tr><td align="center">6~8</td><td>文件的更改时间（mtime）， 或者是文件的最后访问时间（atime）</td></tr><tr><td align="center">9</td><td>文件名称</td></tr></tbody></table><h4 id="touch：创建空文件、更改文件时间"><a href="#touch：创建空文件、更改文件时间" class="headerlink" title="touch：创建空文件、更改文件时间"></a>touch：创建空文件、更改文件时间</h4><ul><li>创建空文件以及更改文件的时间（atime和 mtime）。 </li><li>命令语法：touch [选项] [文件]</li><li>【例4.9】 创建空文件file，file1和file2。<br><code>[root@rhel ~]# touch file1</code><br><code>[root@rhel ~]# touch file2 file3</code><br><code>[root@rhel ~]# ls -l file1 file2 file3</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file1</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file2</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file3</code><br>//file1，file2，file3这3个都是空文件，文件内没有任何数据</li><li>【例4.10】将文件file1的时间记录改为6月7日19点 30分，时间格式为MMDDHHmm。<br><code>[root@rhel ~]# ls -l file1</code><br><code>-rw-r--r--. 1 root root 0 6月 3 05:45 file1</code><br>//空文件file1其创建日期为6月3日5:45<br><code>[root@rhel ~]# touch -c -t 06071930 file1</code><br><code>[root@rhel ~]# ls -l file1 -rw-r--r--. 1 root root 0 6月 7 19:30 file1</code><br>//可以看到文件file1现在的时间已经改为6月7日19点30分</li></ul><h4 id="mkdir：创建目录"><a href="#mkdir：创建目录" class="headerlink" title="mkdir：创建目录"></a>mkdir：创建目录</h4><ul><li>在Linux系统中创建目录。</li><li>命令语法：mkdir [选项] [目录] </li><li>【例4.11】 创建目录newdir1，其默认权限为755。<br>[root@rhel ~]# mkdir newdir1<br>[root@rhel ~]# ls -ld<br>drwxr-xr-x. 2 root root 4096 6月 3 05:46 newdir1<br>//目录newdir1的权限为rwxr-xr-x（755）</li></ul><h4 id="rmdir：删除空目录"><a href="#rmdir：删除空目录" class="headerlink" title="rmdir：删除空目录"></a>rmdir：删除空目录</h4><ul><li>在Linux系统中删除空目录。 </li><li>命令语法： rmdir [选项] [目录] </li><li>【例4.13】 删除空目录newdir1。<br>[root@rhel ~]# rmdir newdir1</li></ul><h4 id="cp：复制文件和目录"><a href="#cp：复制文件和目录" class="headerlink" title="cp：复制文件和目录"></a>cp：复制文件和目录</h4><ul><li>复制文件和目录到其它目录中。如果同时 指定两个以上的文件或目录，且最后的目 的地是一个已经存在的目录，则它会把前 面指定的所有文件或目录复制到该目录中。 若同时指定多个文件或目录，而最后的目 的地并非是一个已存在的目录，则会出现 错误信息。 </li><li>命令语法：cp [选项] [源文件|目录] [目标文件|目录]</li><li>【例4.15】 将/etc/grub2.cfg文件复制到/root目 录下，并改名为grub。<br><code>[root@rhel ~]# cp /etc/grub2.cfg /root/grub</code><br>【例4.16】 将文件/etc/grub2.cfg复制到/root目 录下。<br><code>[root@rhel ~]# cp /etc/grub2.cfg /root</code><br>【例4.17】 将/boot目录中的所有文件及其子目录 复制到目录/root中。<br><code>[root@rhel ~]# cp -r /boot /root</code></li></ul><h4 id="mv：文件和目录改名、移动文件和目录路径"><a href="#mv：文件和目录改名、移动文件和目录路径" class="headerlink" title="mv：文件和目录改名、移动文件和目录路径"></a>mv：文件和目录改名、移动文件和目录路径</h4><ul><li>对文件和目录更改名称以及移动文件和目 录的路径。 </li><li>命令语法：mv [选项] [源文件|目录] [目标文件|目录]</li><li>【例4.18】 将/root/picture目录下所有的后缀名为“.png” 的文件移到/usr/local/share/picture目录下。<br><code>[root@rhel ~]# mv -f /root/picture/*.png /usr/local/share/picture</code><br>【例4.19】 把/root/picture目录下的文件kdepic.png改名 为life.png。<br><code>[root@rhel ~]# mv /root/picture/kdepic.png /root/picture/life.png</code><br>【例4.20】 把目录/root/pitcure名称更改为 /root/mypicture。<br><code>[root@rhel ~]# mv /root/picture /root/mypicture</code></li></ul><h4 id="rm：删除文件或目录"><a href="#rm：删除文件或目录" class="headerlink" title="rm：删除文件或目录"></a>rm：删除文件或目录</h4><ul><li>删除系统中的文件或目录。 </li><li>命令语法：rm [选项] [文件|目录]</li><li>【例4.21】 删除当前目录下的file4文件。<br><code>[root@rhel ~]#rm file4 rm：是否删除普通文件“file4”? y</code><br>//输入y确认删除该文件<br>【例4.22】 连同文件/root/ab/a和目录/root/ab一起删除。<br><code>[root@rhel ~]# mkdir /root/ab</code><br><code>[root@rhel ~]# touch /root/ab/a</code><br>//创建目录/root/ab和文件/root/ab/a<br><code>[root@rhel ~]# rm -rf /root/ab</code><br>//连同文件/root/ab/a和目录/root/ab一起删除</li></ul><h4 id="wc：统计文件行数、单词数和字节数和字符数"><a href="#wc：统计文件行数、单词数和字节数和字符数" class="headerlink" title="wc：统计文件行数、单词数和字节数和字符数"></a>wc：统计文件行数、单词数和字节数和字符数</h4><ul><li>统计指定文件的行数、单词数、字节数和 字符数，并将统计结果显示输出到屏幕。 如果没有给出文件名，则从标准输入读取。 wc同时也给出所有指定文件的总统计数。 单词是由空格字符区分开的最大字符串。 输出列的顺序和数目不受选项的顺序和数目的影响。总是按行数、单词数、字节数、 文件的顺序显示每项信息。 </li><li>命令语法：wc [选项] [文件]</li><li>【例4.23】 统计/root/aa文件的行数、单词数和 字符数。<br><code>[root@rhel ~]#cat /root/aa</code><br>a b<br>c de f<br>中国 g h<br>//查看/root/aa文件内容<br><code>[root@rhel ~]#wc /root/aa</code><br>3 8 22 /root/aa</li></ul><h3 id="4-链接文件"><a href="#4-链接文件" class="headerlink" title="4.链接文件"></a>4.链接文件</h3><ul><li>在Linux系统中，内核为每一个新创建的文 件分配一个inode（索引节点）号，文件属 性保存在索引节点里，在访问文件时，索 引节点被复制到内存里，从而实现文件的快速访问。</li></ul><h4 id="链接文件简介"><a href="#链接文件简介" class="headerlink" title="链接文件简介"></a>链接文件简介</h4><ul><li><p>链接是一种在共享文件和访问它的用户的 若干目录项之间建立联系的方法。Linux系 统中包括硬链接和软链接（也被称为符号链接）两种。</p><ul><li><p>硬链接</p><p>硬链接是一个指针，指向文件inode，系统 并不为它重新分配inode，两文件具有相同的inode。硬链接节省空间，也是Linux系统整合文件系统的传统方式。<br>硬链接文件有两个限制：<br>（1）不允许给目录创建硬链接；<br>（2）只有在同一文件系统中的文件之间才能创建链接。</p></li><li><p>软链接</p><p>软链接也叫符号链接，这个文件包含了另 一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件，和 Windows下的快捷方式相似。链接文件甚 至可以链接不存在的文件，这就产生一般 称之为“断链”的问题，链接文件甚至可以循环链接自己。</p></li></ul></li><li><p>硬链接和软链接的区别</p><p>硬链接记录的是目标的inode，软链接记录 的是目标的路径。软链接就像是快捷方式， 而硬链接就像是备份。软链接可以做跨分 区的链接，而硬链接由于inode的缘故，只 能在本分区中做链接。所以软链接的使用频率要高得多。</p></li></ul><h4 id="创建和使用链接文件"><a href="#创建和使用链接文件" class="headerlink" title="创建和使用链接文件"></a>创建和使用链接文件</h4><ul><li>使用ln命令可以创建链接文件（包括软链 接文件和硬链接文件）。 </li><li>命令语法：ln [选项] [源文件名] [链接文件名]</li><li>【例4.25】 硬链接文件的使用。<br><code>[root@rhel ~]#echo hello &gt; a [root@rhel ~]#ln a b</code><br>【例4.26】 软链接文件的使用。<br><code>[root@rhel ~]#echo hello &gt; a</code><br><code>[root@rhel ~]#ln –s a b</code></li></ul><h2 id="五、Linux常用命令"><a href="#五、Linux常用命令" class="headerlink" title="五、Linux常用命令"></a>五、Linux常用命令</h2><h3 id="1-文本内容显示"><a href="#1-文本内容显示" class="headerlink" title="1.文本内容显示"></a>1.文本内容显示</h3><ul><li>本节主要讲述Linux系统中文本内容显示的相关命令，这些命令有cat，more，less，head，tail，(tail -f)</li></ul><h4 id="cat：显示文本文件"><a href="#cat：显示文本文件" class="headerlink" title="cat：显示文本文件"></a>cat：显示文本文件</h4><ul><li>显示文本文件的内容，也可以把几个文件内容附加到另一个文件中。如果没有指定 文件，或者文件为“-”，那么就从标准输入读取。</li><li>命令语法：cat [选项] [文件]</li><li>【例5.1】 显示/etc/inittab文件的内容。 [root@rhel ~]# cat /etc/inittab<br>【例5.2】 把textfile1文件的内容加上行号后输 入到textfile2文件中。<br><code>[root@rhel ~]# cat -n textfile1 &gt; textfile2</code><br>【例5.3】 使用cat命令创建mm.txt。<br><code>[root@rhel ~]#cat &gt;mm.txt&lt;&lt;EOF</code><br><code>\&gt;Hello</code><br><code>\&gt;Linux</code><br><code>\&gt;EOF</code> //在此输入字符EOF，会自动回到shell提示符界面</li></ul><h4 id="more：分页显示文本文件"><a href="#more：分页显示文本文件" class="headerlink" title="more：分页显示文本文件"></a>more：分页显示文本文件</h4><ul><li>分页显示文本文件的内容。类似于cat命令， 不过是以分页方式显示文件内容，方便使 用者逐页阅读，其最基本的按键就是按空 格键就显示下一页内容，按[b]键返回显示 上一页内容。 </li><li>命令语法：more [选项] [文件名]</li><li>【例5.4】 分页显示/etc/services文件的内容。<br><code>[root@rhel ~]# more /etc/services</code><br>【例5.5】 逐页显示testfile文件内容，如有连续两行以上 空白行则以一行空白行显示。<br><code>[root@rhel ~]# more -s testfile</code><br>【例5.6】 从第20行开始显示testfile文件的内容。<br><code>[root@rhel ~]# more +20 testfile</code><br>【例5.7】 一次两行显示/etc/passwd文件内容。<br><code>[root@rhel ~]# more -2 /etc/passwd</code></li></ul><h4 id="less：回卷显示文本文件"><a href="#less：回卷显示文本文件" class="headerlink" title="less：回卷显示文本文件"></a>less：回卷显示文本文件</h4><ul><li>回卷显示文本文件的内容。less命令的作 用与more十分相似，都可以用来浏览文本 文件的内容，不同的是less命令允许使用 者往回卷动。 </li><li>命令语法：less [选项] [文件名]</li><li>【例5.8】 回卷显示/etc/services文件的内容。<br><code>[root@rhel ~]# less /etc/services</code></li></ul><h4 id="head：显示指定文件前若干行"><a href="#head：显示指定文件前若干行" class="headerlink" title="head：显示指定文件前若干行"></a>head：显示指定文件前若干行</h4><ul><li>显示指定文件的前若干行文件内容。如果没有给出具体行数值，默认缺省设置为10 行。如果没有指定文件，head就从标准输入读取。 </li><li>命令语法：head［选项］[文件]</li><li>【例5.9】 查看/etc/passwd文件的前100个字节数据内容。<br><code>[root@rhel ~]# head –c 100 /etc/passwd</code><br><code>root:x:0:0:root:/root:/bin/bash</code><br><code>bin:\x:1:1:bin:/bin:/sbin/nologin</code><br><code>daemon:x:2:2:daemon:/sbin:/sbin/nol</code><br>【例5.10】 查看/etc/passwd文件的前3行数据内容。<br><code>[root@rhel ~]# head -3 /etc/passwd</code><br><code>root:x:0:0:root:/root:/bin/bash</code><br><code>bin:x:1:1:bin:/bin:/sbin/nologin</code><br><code>daemon:x:2:2:daemon:/sbin:/sbin/nologin</code></li></ul><h4 id="tail：查看文件末尾数据"><a href="#tail：查看文件末尾数据" class="headerlink" title="tail：查看文件末尾数据"></a>tail：查看文件末尾数据</h4><ul><li>查看文件的末尾数据，默认显示指定文件的 最后10 行到标准输出。如果指定了多个文 件，tail会在每段输出的开始添加相应文件 名作为头。如果不指定文件或文件为“-”， 则从标准输入读取数据。 </li><li>命令语法：tail [选项] [文件名]</li><li>【例5.11】查看/etc/passwd文件末尾3行数据内容。<br><code>[root@rhel ~]# tail -3 /etc/passwd</code><br><code>news:x:9:13:News server user:/etc/news:/bin/bash</code><br><code>distcache:x:94:94:Distcache:/:/sbin/nologin</code><br><code>tcpdump:x:72:72::/:/sbin/nologin</code><br>【例5.12】 查看文件/etc/passwd末尾100字节的数据内容。<br><code>[root@rhel ~]# tail -c 100 /etc/passwd</code><br><code>er:/etc/news:/bin/bash</code><br><code>distcache:x:94:94:Distcache:/:/sbin/nologin</code><br><code>tcpdump:x:72:72::/:/sbin/nologin</code></li><li>tail -f 可以实时刷新末尾数据</li></ul><h3 id="2-文本内容处理"><a href="#2-文本内容处理" class="headerlink" title="2.文本内容处理"></a>2.文本内容处理</h3><ul><li>本节主要讲述Linux系统中文本内容处理的相关命令，这些命令有sort，uniq，cut，comm，diff(diff3)。</li></ul><h4 id="sort：对文件中的数据进行排序"><a href="#sort：对文件中的数据进行排序" class="headerlink" title="sort：对文件中的数据进行排序"></a>sort：对文件中的数据进行排序</h4><ul><li>对文件中的数据进行排序，并将结果显示 在标准输出上。 </li><li>命令语法：sort [选项] [文件]</li><li>【例5.13】 将文件textfile1数据排序，并显示在屏幕上。<br><code>[root@rhel ~]# sort textfile1</code><br><code>a</code><br><code>b</code><br><code>c</code><br>【例5.14】读取textfile1文件内容，以倒序排序该文件并显 示在屏幕上。<br><code>[root@rhel ~]# sort -r textfile1</code><br><code>c</code><br><code>b</code><br><code>a</code></li></ul><h4 id="uniq：将重复行从输出文件中删除"><a href="#uniq：将重复行从输出文件中删除" class="headerlink" title="uniq：将重复行从输出文件中删除"></a>uniq：将重复行从输出文件中删除</h4><ul><li>将文件内的重复行数据从输出文件中删除， 只留下每条记录的惟一样本。 </li><li>命令语法：uniq [选项] [文件]</li><li>【例5.15】查看文件file3中重复的数据内容。<br><code>[root@rhel ~]# cat file3 aaa aaa bbb</code><br><code>[root@rhel ~]# uniq -d file3 aaa</code><br>//file3文件中重复行数据的内容为aaa<br>【例5.16】查看文件file3中不重复的数据内容。<br><code>[root@rhel ~]# uniq -u file3</code><br>bbb //file3文件中不重复行数据的内容为bbb</li></ul><h4 id="cut：从文件每行中显示出选定的字节、字符或字段"><a href="#cut：从文件每行中显示出选定的字节、字符或字段" class="headerlink" title="cut：从文件每行中显示出选定的字节、字符或字段"></a>cut：从文件每行中显示出选定的字节、字符或字段</h4><ul><li>从文件的每行中输出选定的字节、字符或字段（域）。只能使用-b、-c或-f选项中的 一个。每一个列表都是专门为一个类别作 出的，或者可以用逗号隔开要同时显示的 不同类别。输入顺序将作为读取顺序，每 个仅能输入一次。</li><li>命令语法：cut [选项] [ 文件 ]</li><li>【例5.17】显示文件/etc/passwd中的用户登录名和用户名全 称字段，这是第1个和第5个字段，由冒号隔开。<br><code>[root@rhel ~]# cut -f 1,5 -d: /etc/passwd</code><br>root:root<br>bin:bin<br>daemon:daemon<br>adm:adm<br>lp:lp<br>……</li></ul><h4 id="comm：逐行比较两个已排过序的文件"><a href="#comm：逐行比较两个已排过序的文件" class="headerlink" title="comm：逐行比较两个已排过序的文件"></a>comm：逐行比较两个已排过序的文件</h4><ul><li><p>比较两个已排过序的文件，并将其结果显 示出来。 </p></li><li><p>命令语法：<br>comm [选项] [文件1] [文件2]</p><table><thead><tr><th>选项</th><th>选项含义</th></tr></thead><tbody><tr><td>-1</td><td>不输出文件1特有的行</td></tr><tr><td>-2</td><td>不输出文件2特有的行</td></tr><tr><td>-3</td><td>不输出两个文件共有的行</td></tr></tbody></table><p>如果没有指定任何参数，comm命令读取这两个文件，然后输出三列：第 1列输出file1中特有的行；第2列输出file2中特有的行；第3列输出两个文件中共有的行。</p></li><li><p>【例5.18】 比较文件file1和file2文件内容。<br><code>[root@rhel ~]# cat file1</code><br>a<br>aa<br><code>[root@rhel ~]# cat file2</code><br>a<br>bb<br>//查看文件file1和file2的文件内容<br><code>[root@rhel ~]# comm file1 file2</code> </p><pre><code>a</code></pre><p>aa </p><pre><code>bb</code></pre><p>【例5.19】 比较文件file1和file2，只显示文件file1和file2中相同行的数据内容。 <code>[root@rhel ~]# comm -12 file1 file2</code><br>a<br>//file1和file2文件中相同行的数据内容是a</p></li></ul><h4 id="diff：逐行比较两个文本文件，列出其不同之处"><a href="#diff：逐行比较两个文本文件，列出其不同之处" class="headerlink" title="diff：逐行比较两个文本文件，列出其不同之处"></a>diff：逐行比较两个文本文件，列出其不同之处</h4><ul><li>逐行比较两个文本文件，列出其不同之处。 它比comm命令能完成更复杂的检查，它对 给出的文件进行系统的检查，并显示出两 个文件中所有不同的行，不要求事先对文 件进行排序。 </li><li>命令语法：diff ［选项］ [文件1] [文件2]</li><li>【例5.20】 比较file1和file2文件，列出其不同之处。<br><code>[root@rhel ~]# cat file1</code><br>a<br>aa<br><code>[root@rhel ~]# cat file2</code><br>a<br>bb<br>//查看文件file1和file2的文件内容<br><code>[root@rhel ~]# diff file1 file2</code><br>2c2<br>&lt; aa<br>-–<br>&gt; bb<br>//可以看到file1和file2文件的不同处是第二行的aa和bb</li></ul><hr><p>update: 2020-7-21</p><h3 id="3-文件和命令查找"><a href="#3-文件和命令查找" class="headerlink" title="3.文件和命令查找"></a>3.文件和命令查找</h3><ul><li>本节主要讲述Linux系统中文件和命令查找 的相关命令，这些命令有grep、find，locate。</li></ul><h4 id="grep：查找文件中符合条件的字符串"><a href="#grep：查找文件中符合条件的字符串" class="headerlink" title="grep：查找文件中符合条件的字符串"></a>grep：查找文件中符合条件的字符串</h4><ul><li>查找文件内符合条件的字符串。 </li><li>命令语法：grep [选项] [查找模式] [文件名]</li><li>【例5.21】在文件kkk中搜索匹配字符“test file”。<br><code>[root@rhel ~]# grep &#39;test file&#39; kkk</code><br>【例5.22】显示所有以d开头的文件中包含“test”的行数据内容。<br><code>[root@rhel ~]# grep &#39;test&#39; d*</code><br>【例5.23】在/root/aa文件中找出以b开头的行内容。<br><code>[root@rhel ~]#grep ^b /root/aa</code><br>【例5.24】在/root/aa文件中找出不是以b开头的行内容。<br><code>[root@rhel ~]# grep -v ^b /root/aa</code><br>【例5.25】在/root/kkk文件中找出以le结尾的行内容。<br><code>[root@rhel ~]# grep le$ /root/kkk</code><br>【例5.26】查找sshd进程信息。<br><code>[root@rhel ~]# ps –ef|grep sshd</code></li></ul><h4 id="find：列出文件系统内符合条件的文件"><a href="#find：列出文件系统内符合条件的文件" class="headerlink" title="find：列出文件系统内符合条件的文件"></a>find：列出文件系统内符合条件的文件</h4><ul><li>将文件系统内符合条件的文件列出来，可以指定文件的名称、类别、时间、大小以 及权限等不同信息的组合，只有完全相符 的文件才会被列出来。 </li><li>命令语法：find [路径] [选项]</li><li>【例5.27】查找/boot目录下的启动菜单配置文件grub.cfg。<br><code>[root@rhel ~]# find /boot -name grub.cfg</code><br>【例5.28】查找/目录下所有以“.conf”为扩展名的文件。<br><code>[root@rhel ~]# find / -name &#39;*.conf&#39;</code><br>【例5.29】列出当前目录及其子目录下所有最近20天内更改 过的文件。<br><code>[root@rhel ~]# find . -ctime -20</code></li></ul><h4 id="locate：在数据库中查找文件"><a href="#locate：在数据库中查找文件" class="headerlink" title="locate：在数据库中查找文件"></a>locate：在数据库中查找文件</h4><ul><li>使用locate命令可以通过数据库 （/var/lib/mlocate/mlocate.db文件）来查找文件，这个数据库每天由cron程序来建立。当创建好这个数据库后，就可以方便地搜寻所需文件了，它比find命令的搜索速度还要快。 </li><li>命令语法：locate [选项][范本样式]</li><li>【例5.34】查找httpd.conf文件。<br><code>[root@rhel ~]# locate httpd.conf</code><br>【例5.35】显示找到几个httpd.conf文件。<br><code>[root@rhel ～]# locate -c httpd.conf</code></li></ul><h3 id="4-系统信息显示"><a href="#4-系统信息显示" class="headerlink" title="4.系统信息显示"></a>4.系统信息显示</h3><ul><li>本节主要讲述Linux系统中信息显示的相关 命令，这些命令有uname、hostname、free、du。</li></ul><h4 id="uname：显示计算机及操作系统相关信息"><a href="#uname：显示计算机及操作系统相关信息" class="headerlink" title="uname：显示计算机及操作系统相关信息"></a>uname：显示计算机及操作系统相关信息</h4><ul><li>显示计算机以及操作系统的相关信息，比 如计算机硬件架构、内核发行号、操作系 统名称、计算机主机名等。 </li><li>命令语法：uname [选项]</li><li>【例5.36】显示操作系统的内核发行号。<br><code>[root@rhel ~]# uname -r</code><br>3.10.0-327.el7.x86_64<br>【例5.37】显示计算机硬件架构名称。<br><code>[root@rhel ~]# uname -m</code><br>X86_64<br>【例5.38】显示操作系统的全部信息。<br><code>[root@rhel ~]# uname -a</code><br>Linux rhel 3.10.0-327.el7.x86_64<br>#1 SMP Thu Oct 29 17:29:29 EDT 2015 x86_64 x86_64<br>x86_64 GNU/Linux</li></ul><h4 id="hostname：显示或修改计算机主机名"><a href="#hostname：显示或修改计算机主机名" class="headerlink" title="hostname：显示或修改计算机主机名"></a>hostname：显示或修改计算机主机名</h4><ul><li><p>显示或修改计算机的主机名。 </p></li><li><p>命令语法： hostname [选项] [主机名|-F &lt;文件&gt;]   设置主机名<br>hostname [选项]    显示格式化主机名</p></li><li><p>【例5.39】显示当前计算机主机名。<br>[root@rhel ~]# hostname rhel //当前计算机主机名为rhel<br>【例5.40】修改计算机主机名为LINUX。<br>[root@rhel ~]# hostname LINUX<br>[root@rhel ~]# hostname<br>LINUX<br>//当前计算机主机名已经更改为LINUX了</p></li><li><p>hostnamectl set-hostname [主机名] 永久修改</p></li></ul><h4 id="free：查看内存信息"><a href="#free：查看内存信息" class="headerlink" title="free：查看内存信息"></a>free：查看内存信息</h4><ul><li>显示系统的物理内存和swap的使用情况。 </li><li>命令语法：free [选项]</li><li>【例5.41】查看系统的物理内存和交换分区使用情况。<br><code>[root@rhel ~]# free</code><br>【例5.42】以MB为单位查看系统的物理内存和交换分区使 用情况。<br><code>[root@rhel ~]# free -m</code><br>【例5.43】显示系统的物理内存加上交换分区总的容量。<br><code>[root@rhel ~]# free -t</code></li></ul><h4 id="du：显示目录或文件的磁盘占用量"><a href="#du：显示目录或文件的磁盘占用量" class="headerlink" title="du：显示目录或文件的磁盘占用量"></a>du：显示目录或文件的磁盘占用量</h4><ul><li><p>显示目录或文件的磁盘占用量。逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块的情况。如果没有给出 文件或目录名称，那么就对当前目录进行 统计。</p></li><li><p>命令语法：du [选项] [文件|目录]</p></li><li><p>【例5.44】显示文件/etc/inittab的磁盘占用量。<br><code>[root@rhel ~]# du /etc/inittab</code><br>【例5.45】显示/root目录磁盘占用量。<br><code>[root@rhel ~]# du –s /root</code><br>【例5.46】以MB为单位显示/root目录磁盘占用量。<br><code>[root@rhel ~]# du –sh /root</code></p></li><li><p>df -sh(显示分区信息)</p></li></ul><h3 id="5-日期和时间"><a href="#5-日期和时间" class="headerlink" title="5.日期和时间"></a>5.日期和时间</h3><ul><li>本节主要讲述Linux系统中查看日期和时间 的相关命令，这些命令有cal、date、hwclock。</li></ul><h4 id="cal：显示日历信息"><a href="#cal：显示日历信息" class="headerlink" title="cal：显示日历信息"></a>cal：显示日历信息</h4><ul><li>显示计算机系统的日历。 </li><li>命令语法：cal [选项] [[[日] 月] 年]</li><li>【例5.47】 显示本月的月历。<br><code>[root@rhel ~]# cal</code><br>【例5.48】 显示公元2001年年历。<br><code>[root@rhel ~]# cal 2001</code><br>【例5.49】 显示公元2007年9月的月历。<br><code>[root@rhel ~]# cal 9 2007</code><br>【例5.50】 以星期一为每周的第一天的方式显示本月的日历。 <code>[root@rhel ~]# cal -m</code><br>【例5.46】 以1月1日起的天数显示今年的年历。<br><code>[root@rhel ~]# cal -jy</code></li></ul><h4 id="date：显示和设置系统日期和时间"><a href="#date：显示和设置系统日期和时间" class="headerlink" title="date：显示和设置系统日期和时间"></a>date：显示和设置系统日期和时间</h4><ul><li>显示和设置计算机系统的日期和时间。只有超级用户才有权限使用date命令设置日期和时间，而一般用户只能使用date命令显示日期和时间。 </li><li>命令语法： date [选项] [显示时间格式]（以+开头，后面接格式）</li><li>【例5.52】 显示当前计算机上的日期和时间。<br><code>[root@rhel ~]# date</code><br>【例5.53】 设置计算机日期和时间为2028年2月2日19点14分。<br><code>[root@rhel ~]# date 0202191428</code><br>【例5.54】 按照指定的格式显示计算机日期和时间。<br><code>[root@rhel ~]# date +&#39;%r%a%d%h%y&#39;</code><br>【例5.55】 设置计算机时间为上午9点16分。<br><code>[root@rhel ~]# date -s 09:16:00</code><br>【例5.56】 设置计算机时间为2024年4月14日。<br><code>[root@rhel ~]# date -s 240414</code></li></ul><h4 id="hwclock：查看和设置硬件时钟"><a href="#hwclock：查看和设置硬件时钟" class="headerlink" title="hwclock：查看和设置硬件时钟"></a>hwclock：查看和设置硬件时钟</h4><ul><li>查看和设置硬件时钟（RTC），可以显示现在时钟，调整硬件时钟，将系统时间设 置成与硬件时钟一致，或是把系统时间回 存到硬件时钟。</li><li>命令语法：hwclock [选项]</li><li>【例5.57】 查看硬件时间。<br><code>[root@rhel ~]# hwclock</code><br>【例5.51】 以系统时间更新硬件时间。<br><code>[root@rhel ~]# hwclock -w</code><br>【例5.52】以硬件时间更新系统时间。<br><code>[root@rhel ~]# hwclock -s</code></li></ul><h3 id="6-信息交流"><a href="#6-信息交流" class="headerlink" title="6.信息交流"></a>6.信息交流</h3><ul><li>本节主要讲述Linux系统中信息交流的相关 命令，这些命令有echo、mesg、wall、write。</li></ul><h4 id="echo：在显示器上显示文字"><a href="#echo：在显示器上显示文字" class="headerlink" title="echo：在显示器上显示文字"></a>echo：在显示器上显示文字</h4><ul><li>在计算机显示器上显示一段文字，一般起到一个 提示的作用。字符串可以加引号，也可以不加引 号。用echo命令输出加引号的字符串时，将字符串按原样输出；用echo命令输出不加引号的字符 串时，将字符串中的各个单词作为字符串输出， 各字符串之间用一个空格分隔。</li><li>命令语法：echo [选项] [字符串]</li><li>【例5.60】 将一段信息写到标准输出。<br><code>[root@rhel ~]# echo Hello Linux Hello Linux</code><br>【例5.61】 将文本“Hello Linux”添加到新文件notes中。<br><code>[root@rhel ~]# echo Hello Linux &gt; notes</code><br><code>[root@rhel ~]# cat notes Hello Linux</code><br>//查看文件notes，可以看到文件中的内容为hello Linux<br>【例5.62】 显示$HOME变量的值。<br><code>[root@rhel ~]# echo $HOME</code><br>/root</li></ul><h4 id="mesg：允许或拒绝写消息"><a href="#mesg：允许或拒绝写消息" class="headerlink" title="mesg：允许或拒绝写消息"></a>mesg：允许或拒绝写消息</h4><ul><li>控制系统中的其它用户是否能够用 write 命 令或 talk 命令向您发送消息。不带选项的 情况下，mesg 命令显示当前主机消息许可 设置。</li><li>命令语法：mesg [选项]</li><li>【例5.63】显示当前的消息许可设置。<br><code>[root@rhel ~]# mesg</code><br>is y<br>//允许本地网络上的所有主机发送消息到自己的主机<br>【例5.64】只允许root用户发送消息到自己的主机。<br><code>[root@rhel ~]# mesg n</code><br><code>[root@rhel ~]# mesg</code><br>is n</li></ul><h4 id="wall：对全部已登录用户发送信息"><a href="#wall：对全部已登录用户发送信息" class="headerlink" title="wall：对全部已登录用户发送信息"></a>wall：对全部已登录用户发送信息</h4><ul><li>对全部已登录的用户发送信息。 </li><li>命令语法： wall [消息] </li><li>【例5.66】 向所有用户发出“下班以后请关闭计算机。” 的信息。<br><code>[root@rhel ~]# wall &#39;下班以后请关闭计算机&#39;</code><br>[root@rhel ~]#<br>Broadcast message from root@rhel (pts/1)<br>(Sun Jun 3 05:38:14 2012):<br>下班以后请关闭计算机</li></ul><h4 id="write：向用户发送消息"><a href="#write：向用户发送消息" class="headerlink" title="write：向用户发送消息"></a>write：向用户发送消息</h4><ul><li>向用户发送消息。 </li><li>命令语法：write [用户] [终端名称] </li><li>【例5.67】在tty2终端上向tty3终端上的root用户发送信息。<br><code>[root@rhel ~]# write root tty3</code><br>hello<br>//在tty2终端上输入要发送的信息，输入完毕，希望退出发送状态时，按组合键[Ctrl+c]即可<br><code>[root@rhel ～]# Message from root@rhel on tty2 at 05:39 ...</code><br><code>hello</code><br>EOF`<br>//在终端tty3上，用户root会接收到以上信息，要结束时，按[Ctrl+c]组合键即可</li></ul><h3 id="7-其他命令"><a href="#7-其他命令" class="headerlink" title="7.其他命令"></a>7.其他命令</h3><hr><p>update：2020-07-22</p><h2 id="六、Shell编程"><a href="#六、Shell编程" class="headerlink" title="六、Shell编程"></a>六、Shell编程</h2><h3 id="熟悉Shell程序的创建"><a href="#熟悉Shell程序的创建" class="headerlink" title="熟悉Shell程序的创建"></a>熟悉Shell程序的创建</h3><ul><li>作为命令语言互动式地解释和执行用户输入的命令是Shell的功能之一，She11还可以用来进行程序设计，它提供了定义变量和参数的手段以及丰富的过程控制结构。使用She11编程类似于使用DOS中的批处理文件，称为Shell脚本，又叫做She11程序或She11命令文件。</li></ul><h4 id="语法基本介绍"><a href="#语法基本介绍" class="headerlink" title="语法基本介绍"></a>语法基本介绍</h4><ul><li>She11程序基本语法较为简单，主要由开头部分、注释部分以及语句执行部分组成。</li></ul><p><strong>1.开头</strong></p><p>She11程序必须以下面的行开始（必须放在文件的第一行）。<br>#!/bin/bash。</p><p>符号“#~”用来告诉系统它后面的参数是用来执行该文件的程序，在这个例子中使用/bin/bash来执行程序。当编辑好脚本时，如果要执行该脚本，还必须使其可执行。</p><p>要使脚本可执行，需赋予该文件可执行的权限，使用如下命令文件才能运行。<br>chmod u+x[文件名]</p><p><strong>2.注释</strong></p><p>在进行Shell编程时，以“#”开头的句子 表示注释，直到这一行的结束，建议在程 序中使用注释。如果使用注释，那么即使相当长的时间内没有使用该脚本，也能在很短的时间内明白该脚本的作用及工作原理。</p><p><strong>3.执行命令</strong></p><p>在She11程序中可以输入多行命令以得到命令的结果信息，这样就提高系统管理的工作效率。</p><h4 id="1-创建文件"><a href="#1-创建文件" class="headerlink" title="1.创建文件"></a>1.创建文件</h4><p>在/root目录下使用vi编辑器创建文件date，该文件内容如下所示，共有3个命令。<br>#！/bin/bash<br>#filename:date<br>echo “Mr.$USER，Today is:”<br>echo `date`<br>echo Whish you a lucky day！</p><h4 id="2-设置执行权限"><a href="#2-设置执行权限" class="headerlink" title="2.设置执行权限"></a>2.设置执行权限</h4><p>创建完date文件之后它还不能执行，需要给它设置可执行权限，使用如下命令给文件设置权限。<br><code>[root@rhel~]#chmod u+x /root/date</code><br><code>[root@rhel ~]#Is-1/root/date</code><br>-rwxr–r–.1 root root 886月305：37/root/date<br>/可以看到当前date文件具有可执行权限</p><h4 id="3-执行Shell程序"><a href="#3-执行Shell程序" class="headerlink" title="3.执行Shell程序"></a>3.执行Shell程序</h4><p>输入整个文件的完整路径执行Shell程序，使用如下命令执行。<br>[root@rhel ~]#/root/date<br>Mr.root，Today is：<br>2012年06月03日星期日05：37：34 CST<br>Whish you a lucky day！<br>/可以看到Shell程序的输出信息</p><h4 id="4-使用bash命令执行程序"><a href="#4-使用bash命令执行程序" class="headerlink" title="4.使用bash命令执行程序"></a>4.使用bash命令执行程序</h4><p>在执行Shell程序时需要将date文件设置为可执行权限。如果不设置文件的可执行权限，那么需要使用bash命令告诉系统它是一个可执行的脚本，使用如下命令执行Shell程序。<br>[root@rhel~]#bash /root/date<br>Mr.root，Today is：<br>2012年06月03日星期日05：37：34 CST<br>Whish you a lucky day！</p><h3 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h3><p>像高级程序设计语言一样，Shell也提供说明和使用变量的功能。对Shell来讲，所有变量的取值都是一个字符，Shell程序采用“$var”的形式来引用名为var的变量的值。</p><h4 id="Shell定义的环境变量"><a href="#Shell定义的环境变量" class="headerlink" title="Shell定义的环境变量"></a>Shell定义的环境变量</h4><p>Shell在开始执行时就已经定义了一些与系 统的工作环境有关的变量，用户还可以重新定义这些变量。</p><h4 id="常用的Shell环境变量"><a href="#常用的Shell环境变量" class="headerlink" title="常用的Shell环境变量"></a>常用的Shell环境变量</h4><table><thead><tr><th>Shell环境变量</th><th>描述</th></tr></thead><tbody><tr><td>HOME</td><td>用于保存用户主目录的完全路径名</td></tr><tr><td>PATH</td><td>用于保存用冒号分隔的目录路径名，Shell将按PATH变量中给出的顺序 搜索这些目录，找到的第一个与命令名称一致的可执行文件将被执行</td></tr><tr><td>UID</td><td>当前用户的UID，由数字构成</td></tr><tr><td>PWD</td><td>当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化</td></tr><tr><td>PS1</td><td>主提示符，在root用户下，默认的主提示符是“#”，在普通用户下，默 认的主提示符是“$”</td></tr><tr><td>PS2</td><td>在Shell接收用户输入命令的过程中，如果用户在输入行的末尾输入“\” 然后按回车键，或者当用户按回车键时Shell判断出用户输入的命令没 有结束时，就显示这个辅助提示符，提示用户继续输入命令的其余部分，默认的辅助提示符是“&gt;”</td></tr><tr><td>TERM</td><td>终端的类型</td></tr></tbody></table><h4 id="用户定义的变量"><a href="#用户定义的变量" class="headerlink" title="用户定义的变量"></a>用户定义的变量</h4><ul><li>用户可以按照下面的语法规则定义自己的变量。 变量名=变量值</li><li>在定义变量时，变量名前不应该加符号“$”，在 引用变量的内容时则应在变量名前加符号“$”。</li><li>在给变量赋值时，等号两边一定不能留空格，若变量中本身就包含了空格，则整个字符串都要用 双引号括起来。在编写Shell程序时，为了使变量 名和命令名相区别，建议所有的变量名都用大写<br>字母来表示。</li><li>【例6.2】用户定义变量的使用。<br><code>[root@rhel ~]# \$AS=120</code><br>bash: =120: 未找到命令…<br>//在定义变量名时，变量名前加符号“$”就报错<br><code>[root@rhel ~]# AS=120</code><br><code>[root@rhel ~]# echo ​\$AS</code><br>120<br>//在引用变量名时，在变量名前加 符号“$”<br><code>[root@rhel ~]# AA=&quot;hello word&quot;</code><br> //变量值中包含了空格，需将整个字符串用双引号括起来<br><code>[root@rhel ~]# echo $AA</code><br>hello word</li><li>有时需要在说明一个变量并对它设置为一 个特定值后就不再改变它的值时，可以用 下面的命令来保证一个变量的只读性。<br>readonly 变量名</li><li>在任何时候创建的变量都只是当前Shell的局部变量，所以不能被Shell运行的其他命令或Shell 程序所利用，而export命令可以将一个局部变量 提供给Shell命令使用，其格式是： export 变量名</li><li>也可以在给变量赋值的同时使用export命令： export 变量名=变量值</li><li>使用export说明的变量在Shell以后运行的所有<br>命令或程序中都可以访问到。</li></ul><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>位置参数是一种在调用Shell程序的命令行 中按照各自的位置决定的变量，是在程序 名之后输入的参数。位置参数之间用空格 分隔，Shell取第一个位置参数替换程序文 件中的$1，第二个替换​$2，依次类推。$0 是一个特殊的变量，它的内容是当前这个 Shell程序的文件名，所以$0不是一个位置 参数，在显示当前所有的位置参数时是不包括$0的。</p><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>预定义变量和环境变量相类似，也是在 Shell一开始时就定义了的变量。所不同的 是，用户只能根据Shell的定义来使用这些 变量，所有预定义变量都是由符号“$”和另一个符号组成的。</p><p><strong>常用的Shell预定义变量</strong></p><table><thead><tr><th>预定义变量</th><th>描述</th></tr></thead><tbody><tr><td>$#</td><td>位置参数的数量</td></tr><tr><td>$*</td><td>所有位置参数的内容</td></tr><tr><td>$?</td><td>命令执行后返回的状态，0表示没有错误，非0表示有错误</td></tr><tr><td>$$</td><td>当前进程的进程号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程号</td></tr><tr><td>$0</td><td>当前执行的进程名</td></tr></tbody></table><h4 id="参数置换的变量"><a href="#参数置换的变量" class="headerlink" title="参数置换的变量"></a>参数置换的变量</h4><p>Shell提供了参数置换功能以便用户可以根 据不同的条件来给变量赋不同的值。参数 置换的变量有四种，这些变量通常与某一 个位置参数相联系，根据指定的位置参数是否已经设置决定变量的取值。</p><p>1．变量=${参数-word}<br>如果设置了参数，则用参数的值置换变量的值，否则用word置换， 即这种变量的值等于某一个参数的值。如果该参数没有设置，则变量就等于word值。<br>2．变量=${参数=word}<br>如果设置了参数，则用参数的值置换变量的值，否则把变量设置成 word，然后再用word替换参数的值。位置参数不能用于这种方式， 因为在shell程序中不能为位置参数赋值。<br>3．变量${参数?word}<br>如果设置了参数，则用参数的值置换变量的值，否则就显示word并 从shell中退出，如果省略了word，则显示标准信息。这种变量要求 一定等于某一个参数的值。如果该参数没有设置，就显示一个信息， 然后退出，这种方式常用于出错指示。<br>4．变量=${参数+word}<br>如果设置了参数，则用word置换变量，否则不进行置换。</p><h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><h3 id="Shell条件判断语句"><a href="#Shell条件判断语句" class="headerlink" title="Shell条件判断语句"></a>Shell条件判断语句</h3><h3 id="Shell循环控制语句"><a href="#Shell循环控制语句" class="headerlink" title="Shell循环控制语句"></a>Shell循环控制语句</h3><hr><p>update：2020-07-22</p><h2 id="七、用户和组群账户管理"><a href="#七、用户和组群账户管理" class="headerlink" title="七、用户和组群账户管理"></a>七、用户和组群账户管理</h2><p>在Linux系统中，用户账户是登录系统的唯 一凭证，其中root用户是系统的最高管理 者，该用户的UID是0级，与用户和组账户 相关的配置文件有/etc/passwd、/etc/shadow、/etc/group和/etc/gshadow。</p><h3 id="用户账户简介"><a href="#用户账户简介" class="headerlink" title="用户账户简介"></a>用户账户简介</h3><p>本节主要讲述Linux系统中的用户账户分类 以及与用户账户有关的配置文件/etc/passwd和/etc/shadow。</p><h4 id="用户账户分类"><a href="#用户账户分类" class="headerlink" title="用户账户分类"></a>用户账户分类</h4><p>用户账户在Linux系统中是分角色的，由于角色不同，每个用户的权限和所能完成的 任务也不同。而在实际的管理中，用户的 角色是通过UID（用户ID号）来标识的，每 个用户的UID都是不同的。<br>在Linux系统中有三大类用户，分别是root用户、系统用户和普通用户。</p><h4 id="1．root用户"><a href="#1．root用户" class="headerlink" title="1．root用户"></a>1．root用户</h4><p>在Linux系统中，root用户UID为0。root用 户的权限是最高的，普通用户无法执行的 操作，root用户都能完成，所以也被称之 为超级用户。在系统中的每个文件、目录 和进程都归属于某一个用户，没有用户许 可，其它普通用户无法进行操作的，但对root用户除外。</p><h4 id="2．系统用户"><a href="#2．系统用户" class="headerlink" title="2．系统用户"></a>2．系统用户</h4><p>系统用户也称为虚拟用户、伪用户或假用 户，这类用户不具有登录Linux系统的能力， 但却是系统运行不可缺少的用户，比如bin、 daemon、adm、ftp、mail等，这类用户都是系统自身拥有的。系统用户的UID为1~999。</p><h4 id="3．普通用户"><a href="#3．普通用户" class="headerlink" title="3．普通用户"></a>3．普通用户</h4><p>这类用户能登录系统，在Linux系统上进行 普通操作，能操作自己目录的内容，其使 用系统的权限受限，这类用户都是系统管理员创建的。普通用户的UID为1000~60000。</p><h4 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h4><p>/etc/passwd文件是系统识别用户的一个重要文件， Linux系统中所有的用户都记录在该文件中。假设 用户以账户zhangsan登录系统时，系统首先会检 查/etc/passwd文件，看是否有zhangsan这个账户， 然后确定用户zhangsan的UID，通过UID来确认用 户的身份，如果存在则读取/etc/shadow文件中所 对应的密码。如果密码核实无误则登录系统，读取用户的配置文件。</p><p>任何用户都可以读取/etc/passwd文件内容，在 /etc/passwd文件中，每一行表示的是一个用户账 户的信息，一行有7个段位，每个段位用“:”分隔。<br><code>zhangsan:x:1000:1000:张三:/home/zhangsan:/bin/bash</code></p><h4 id="etc-passwd文件字段含义"><a href="#etc-passwd文件字段含义" class="headerlink" title="/etc/passwd文件字段含义"></a>/etc/passwd文件字段含义</h4><table><thead><tr><th>字段</th><th>字段含义</th></tr></thead><tbody><tr><td>用户名</td><td>也称为登录名，在系统内用户名应该具有惟一性。在本例中， zhangsan就是用户名</td></tr><tr><td>密码</td><td>存放加密用户的密码，看到的是一个x，其实密码已被映射到 /etc/shadow文件中</td></tr><tr><td>用户标识号 （UID）</td><td>在系统内用一个整数标识用户ID号，每个用户的UID都是惟一 的，root用户的UID是0，普通用户的UID默认从1000开始，本例中的用户zhangsan的UID是1000</td></tr><tr><td>组群标识号 （GID）</td><td>在系统内用一个整数标识用户所属的主要组群ID号，每个组群 的GID都是惟一的</td></tr><tr><td>用户名全称</td><td>用户名描述，可以不设置。在本例中，zhangsan用户的用户名 全称是张三</td></tr><tr><td>主目录</td><td>用户登录系统后首先进入的目录，zhangsan用户的主目录是 /home/zhangsan</td></tr><tr><td>登录Shell</td><td>用户使用的Shell类型，Linux系统默认使用的Shell是/bin/bash</td></tr></tbody></table><p><strong>用户UID</strong></p><p>UID是用户的ID值，在系统中每一位用户的UID值 都是惟一的，更确切地说每一位用户都要对应一 个惟一的UID。Linux系统用户的UID值是一个正整数，初始值从0开始，在Linux系统中默认的最大值是60000。</p><p>在Linux系统中，root的UID是0，拥有系统最高 权限。UID的唯一性关系到系统的安全，比如在 /etc/passwd文件中把用户zhangsan的UID改为0 后，zhangsan这个用户会被确认为root用户，当 用这个账户登录到系统后，可以进行所有root用户才能执行的操作。</p><p>UID是确认用户权限的标识，用户登录系统所处 的角色是通过UID来实现的，而不是用户名。一 般情况下，Linux的发行版本都会预留一定的UID 给系统虚拟用户使用，比如ftp、nobody、adm、 bin以及shutdown等用户账户。在Linux系统中会 把1~999的UID预留出来给虚拟用户使用，管理员所创建的新用户UID默认是从1000开始的。</p><h4 id="etc-shadow文件"><a href="#etc-shadow文件" class="headerlink" title="/etc/shadow文件"></a>/etc/shadow文件</h4><p>/etc/shadow文件是/etc/passwd的影子文件，这 个文件并不是由/etc/passwd文件产生，这两个文件应该是对应互补的。/etc/shadow文件内容包括用户及被加密的密码以及其它/etc/passwd不能包括的信息，比如用户账户的有效期限等。</p><p>/etc/shadow文件只有root用可以读取和操作，文 件的权限不能随便更改为其它用户可读，这样做 是非常危险的。如果发现这个文件的权限变成了 其它组群或用户可读了，要进行检查，以防系统安全问题的发生。</p><p>/etc/shadow文件的内容包括9个段位，每个段位 之间用“:”分隔。<br><code>zhangsan:$6$E/xvWMmh$rhYLQwwffEqIudVLFzMlvkb0iN4.0Oluk6H.UovEYN0/99dVoHXcaCNGZZkFY1S3QHYgm7e6JPzEew6ybmN4e0:16364:0:99999:7:::</code></p><h4 id="etc-shadow文件字段含义"><a href="#etc-shadow文件字段含义" class="headerlink" title="/etc/shadow文件字段含义"></a>/etc/shadow文件字段含义</h4><table><thead><tr><th>字段</th><th>字段含义</th></tr></thead><tbody><tr><td>用户名</td><td>这里的用户名和/etc/passwd中的用户名是相同的</td></tr><tr><td>加密密码</td><td>密码已经加密，如果有些用户在这里显示的是“!!”，则表示这个用户还没有设置密码，不能登录到系统</td></tr><tr><td>用户最后一次更改密码的日期</td><td>从1970年1月1日算起到最后一次修改密码的时间间隔天数</td></tr><tr><td>密码允许更换前的天数</td><td>如果设置为0，则禁用此功能。该字段是指用户可以更改密码的天数</td></tr><tr><td>密码需要更换的天数</td><td>如果设置为0，则禁用此功能。该字段是指用户必须更改密码的天数</td></tr><tr><td>密码更换前警告的天数</td><td>用户登录系统后，系统登录程序提醒用户密码将要过期</td></tr><tr><td>账户被取消激活前的天数</td><td>表示用户密码过期多少天后，系统会禁用此用户，也就是说系统会不让此用户登录，也不会提示用户过期，是完全禁用的</td></tr><tr><td>用户账户过期日期</td><td>指定用户账户禁用的天数（从1970年的1月1日开始到账户被禁用的天数），如果这个字段的值为空，账户永久可用</td></tr><tr><td>保留字段</td><td>目前为空，以备将来Linux系统发展时使用</td></tr></tbody></table><p><strong>/etc/login.defs 产生用户初始配置信息</strong></p><p><strong>/etc/skel 新创建用户主目录包含的文件</strong></p><h3 id="用户账户设置"><a href="#用户账户设置" class="headerlink" title="用户账户设置"></a>用户账户设置</h3><p>在Linux系统字符界面中创建、修改以及删 除用户账户主要使用useradd，usermod和userdel这3个命令。</p><h4 id="创建用户账户"><a href="#创建用户账户" class="headerlink" title="创建用户账户"></a>创建用户账户</h4><p>创建用户账户就是在系统中创建一个新账 户，为新账户分配用户UID、组群、主目录 和登录Shell等资源，新创建的用户账户默 认是被锁定的，无法使用，需要使用 passwd命令设置密码以后才能使用。创建用户账户就是在/etc/passwd文件中为新用户增加一条记录，同时更新/etc/shadow和/etc/group文件。</p><p>使用useradd命令都可以在Linux系统中创 建用户账户。</p><p>命令语法：useradd [选项] [用户名]</p><p>【例7.1】 创建用户账户zhangsan并设置密码。<br><code>[root@rhel ~]# useradd zhangsan</code><br><code>[root@rhel ~]# cat /etc/passwd|grep zhangsan</code><br><code>zhangsan:x:1000:1000::/home/zhangsan:/bin/bash</code><br>//查看/etc/passwd文件，显示已经创建了用户zhangsan<br><code>[root@rhel ~]# passwd zhangsan</code><br>更改用户 zhangsan 的密码。<br>新的密码：//在此设置用户zhangsan的密码<br>重新输入新的密码： //重复设置用户zhangsan的密码<br>passwd：所有的身份验证令牌已经成功更新。</p><p>【例7.2】 对用户账户设置密码和不设置密码的比较。<br><code>[root@rhel ~]# useradd lisi</code><br><code>[root@rhel ~]# useradd wangwu</code><br>//创建用户lisi和wangwu<br><code>[root@rhel ~]# passwd wangwu</code><br>更改用户wangwu 的密码<br>新的密码：//在此设置用户wangwu的密码<br>重新输入新的密码： //重复设置用户wangwu的密码<br><code>[root@rhel ~]# cat /etc/passwd|grep lisi</code><br><code>lisi:x:1001:1001::/home/lisi:/bin/bash</code><br><code>[root@rhel ~]# cat /etc/shadow|grep lisi</code><br><code>lisi:!!:15493:0:99999:7:::</code><br>//查看/etc/shadow文件，显示在用户lisi的密码字段上显示的是“!!”，表示该用户还没有设置密码，不能登录到Linux系统上<br><code>[root@rhel ~]# cat /etc/passwd|grep wangwu</code><br><code>wangwu:x:1002:1002::/home/wangwu:/bin/bash</code><br><code>[root@rhel ~]# cat /etc/shadow|grep wangwu</code><br><code>wangwu:\$6\$KiAI6cI.$p/kEL0heCQBGdEH6/XoSh30Utke6Tx8IJAtVKiBnM1oDIQlwp.Jci W1limKz1NmVKP7.0BZ9pF1LcfEzxprpk1:15493:0:99999:7:::</code><br>//查看/etc/shadow文件，可以看到在用户wangwu的密码字段上显示的是加密的密码，表示该用户已经设置密码，能登录到Linux系统上</p><p>【例7.3】 创建用户moon，并设置该用户UID为1510。<br><code>[root@rhel ~]# useradd -u 1010 moon</code><br><code>[root@rhel ~]# cat /etc/passwd|grep moon</code><br><code>moon:x:1010:1010::/home/moon:/bin/bash</code><br>//查看/etc/passwd文件，可以看到用户moon的UID是1010</p><h4 id="修改用户账户"><a href="#修改用户账户" class="headerlink" title="修改用户账户"></a>修改用户账户</h4><p>使用usermod命令可以更改用户的Shell类 型、所属的组群、用户密码的有效期，还 能更改用户的登录名。 </p><p>命令语法：usermod [选项][用户名]</p><p>【例7.7】 修改用户zhangsan的主目录为/home/kkk，并手动创建/home/kkk目录。<br><code>[root@rhel ~]# usermod -d /home/kkk zhangsan</code><br><code>[root@rhel ~]# cat /etc/passwd|grep zhangsan</code><br><code>zhangsan:x:1000:1000::/home/kkk:/bin/bash</code><br>//查看/etc/passwd文件，可以看到用户zhangsan的主目录已经更改为/home/kkk<br><code>[root@rhel ~]# mkdir /home/kkk</code><br>//必须使用mkdir命令创建/home/kkk目录，这样用户zhangsan才能使用该主目录</p><p>【例7.8】 修改用户wangwu的主目录为/home/opop，并自动创建 /home/opop目录。<br><code>[root@rhel ~]# ls /home</code><br><code>abc kkk lisi moon pp wangwu www zhangsan</code><br><code>[root@rhel ~]# cat /etc/passwd|grep wangwu</code><br><code>wangwu:x:1002:1002::/home/wangwu:/bin/bash</code><br>//查看/home目录和/etc/passwd文件内容，可以看到用户wangwu的当前主目录是/home/wangwu<br><code>[root@rhel ~]# usermod -d /home/opop -m wangwu</code><br><code>[root@rhel ~]# ls /home</code><br><code>abc kkk lisi moon opop pp www zhangsan</code><br><code>[root@rhel ~]# cat /etc/passwd|grep wangwu</code><br><code>wangwu:x:1002:1002::/home/opop:/bin/bash</code><br>//查看/home目录和/etc/passwd文件内容，可以看到用户wangwu的主目录自动由/home/wangwu改为/home/opop</p><h4 id="删除用户账户"><a href="#删除用户账户" class="headerlink" title="删除用户账户"></a>删除用户账户</h4><p>使用userdel命令可以在Linux系统中删除用 户账户，甚至连用户的主目录也一起删除。</p><p> 命令语法：userdel [选项][用户名]</p><p>【例7.17】 删除用户lisi。<br><code>[root@rhel ~]# userdel lisi</code><br><code>[root@rhel ~]# cat /etc/passwd|grep lisi</code><br>//查看/etc/passwd文件，已经查询不到关于用户lisi的数据，说明该账户已 经删除<br><code>[root@rhel ~]# ls /home</code><br><code>abc kkk lisi moon opop pp www zhangsan</code><br>//使用userdel命令删除用户账户并不会删除该用户主目录<br>【例7.18】 删除用户moon，并且在删除该用户的同时一起删除主目录。<br><code>[root@rhel ~]# ls /home</code><br><code>abc kkk lisi moon opop pp www zhangsan</code><br>//用户moon的主目录为/home/moon<br><code>[root@rhel ~]# userdel -r moon</code><br><code>[root@rhel ~]# ls /home</code><br><code>abc kkk lisi opop pp www zhangsan</code><br>//查看/home目录的内容，可以看到用户moon的主目录随该用户一起删除了</p><h3 id="组群账户简介"><a href="#组群账户简介" class="headerlink" title="组群账户简介"></a>组群账户简介</h3><p>本节主要讲述Linux系统下的组群账户分类 以及与组群账户有关的配置文件<br>/etc/group和/etc/gshadow。</p><h4 id="组群账户分类"><a href="#组群账户分类" class="headerlink" title="组群账户分类"></a>组群账户分类</h4><p>具有某种共同特征的用户集合就是组群。通过组 群可以集中设置访问权限和分配管理任务。<br>在Linux系统中，有两种组群分类方法。 一种方法将组群分为私有组群和标准组群。</p><p> 1．私有组群：当创建一个新的用户账户时，如果 没有指定该用户属于哪一个组群，那么Linux就会 创建一个和该用户同名的组群，这个组群就是私有组群，在这个私有组群中只包含这个用户。</p><p>2 ．标准组群：标准组群也称为普通组群，标准组群可以包含多个用户账户，如果使用标准组群， 那么在创建一个新的用户账户时，应该指定该用户属于哪一个组群。</p><p>另外一种方法将组群分为主要组群和次要组群。 </p><p>1．主要组群：当一个用户账户属于多个组成员时， 登陆后所属的组群便是主要群组，其它组群是次要群组，一个用户账户只能属于一个主要组群。</p><p>2．次要组群：次要群组也称附加群组，一个用户账户可以属于多个次要群组。</p><h4 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a>/etc/group文件</h4><p>/etc/group文件是组群的配置文件，内容包括用户和组群， 并且能显示出用户是归属哪个组群或哪几个组群。一个用户可以归属一个或多个不同的组群，同一组群的用户之间具有相似的特征。比如把某一用户加入到root组群，那么这个用户就可以浏览root用户主目录的文件，如果root用户把某个文件的读写执行权限开放，root组群的所有用户都可以修改此文件；如果是可执行的文件，root组群的用户也是可以执行的。</p><p>组群的特性在系统管理中为系统管理员提供了极大的方便， 但安全性也是值得关注的，如某个用户有对系统管理有最 重要的内容，最好让用户拥有独立的组群，或者把用户的 文件的权限设置为完全私有。</p><p>/etc/group文件的内容包括组群名、组群密码、GID及该 组群所包含的用户，每个组群一条记录，一行有4个段位， 每个段位用“:”分隔。<br><code>zhangsan:x:1000:</code></p><h4 id="etc-group文件字段含义"><a href="#etc-group文件字段含义" class="headerlink" title="/etc/group文件字段含义"></a>/etc/group文件字段含义</h4><table><thead><tr><th>字段</th><th>字段含义</th></tr></thead><tbody><tr><td>组群名</td><td>组群名称，如组群名root</td></tr><tr><td>组群密码</td><td>存放加密的组群密码，看到一个x，密码已被映射 到/etc/gshadow文件中</td></tr><tr><td>组群标识号（GID）</td><td>在系统内用一个整数标识组群GID，每个组群的 GID都是惟一的，默认普通组群的GID从1000开始，root组群GID是0</td></tr><tr><td>组群成员</td><td>属于这个组群的成员，如root组群的成员有root用户</td></tr></tbody></table><p><strong>组群GID</strong></p><p>组群GID和UID类似，是一个从0开始的正整数，GID为0的组群是root组群。Linux系统会预留GID号1~999给系统虚拟组群使用， 创建的新组群GID是从1000开始的，查看系统创建组群默认的GID范围应该查看 /etc/login.defs中的GID_MIN和GID_MAX值，可以使用以下命令查看。</p><h4 id="etc-gshadow文件"><a href="#etc-gshadow文件" class="headerlink" title="/etc/gshadow文件"></a>/etc/gshadow文件</h4><p>/etc/gshadow是/etc/group的加密文件，组群密码就是存放在这个文件中。/etc/gshadow和 /etc/group是互补的两个文件；对于大型服务器，针对很多用户和组群，定制一些关系结构比较复杂的权限模型，设置组群密码是很有必要的。比如不想让一些非组群成员永久拥有组群的权限和特性，可以通过密码验证的方式来让某些用户临时拥有一些组群特性，这时就要用到组群密码。</p><p>/etc/gshadow文件中每个组群都有一条记录。一 行有4个段位，每个段位用“:”分隔。<br><code>beijing:$6$E/xvWMmh$rhYLQwwffEqIudVLFzMlv1::ou</code></p><h4 id="etc-gshadow文件字段含义"><a href="#etc-gshadow文件字段含义" class="headerlink" title="/etc/gshadow文件字段含义"></a>/etc/gshadow文件字段含义</h4><table><thead><tr><th>字段</th><th>字段含义</th></tr></thead><tbody><tr><td>组群名</td><td>组群的名称</td></tr><tr><td>组群密码</td><td>密码已经加密，如果有些组群在这里显示的是 “!”，表示这个组群没有密码。本例中组群shanghai没有密码，组群beijing已设置密码</td></tr><tr><td>组群管理者</td><td>组群的管理者，有权在该组群中添加、删除用户</td></tr><tr><td>组群成员</td><td>属于该组群的用户成员列表，如有多个用户用逗 号分隔。本例中beijing组群的成员是ou</td></tr></tbody></table><h3 id="组群账户设置"><a href="#组群账户设置" class="headerlink" title="组群账户设置"></a>组群账户设置</h3><p>在Linux系统字符界面下创建、修改以及删 除组群账户主要使用groupadd，groupmod和groupdel这3个命令。</p><h4 id="创建组群账户"><a href="#创建组群账户" class="headerlink" title="创建组群账户"></a>创建组群账户</h4><p>使用groupadd命令可以在Linux系统中创建组群账户。 </p><p>命令语法：groupadd [选项] [组群名]</p><p>【例7.19】 创建名为china的组群。<br><code>[root@rhel ~]# groupadd china</code><br><code>[root@rhel ~]# cat /etc/group|grep china</code><br><code>china:x:1006:</code><br>//查看文件/etc/group，可以看到已经创建了组群china，组群GID是1006<br>【例7.20】 创建名为ou的组群，并且设置该组群GID为1800。<br><code>[root@rhel ~]# groupadd -g 1800 ou</code><br><code>[root@rhel ~]# cat /etc/group|grep ou</code><br><code>ou:x:1800:</code><br>//查看文件/etc/group，可以看到已经创建了组群ou，组群GID是1800<br>【例7.21】 创建名为chinese的系统组群。<br><code>[root@rhel ~]# groupadd -r chinese</code><br><code>[root@rhel ~]# cat /etc/group|grep chinese</code><br><code>chinese:x:982:</code><br>//查看/etc/group文件，可以看到系统组群chinese的GID是982，是小于1000的</p><h4 id="修改组群账户"><a href="#修改组群账户" class="headerlink" title="修改组群账户"></a>修改组群账户</h4><p>使用groupmod命令可以在Linux系统中修 改组群账户，比如组群名称、GID等。 命令语法：<br>groupmod [选项][组群名]</p><p>【例7.22】 将组群ou的GID修改为1900。<br><code>[root@rhel ~]# groupmod -g 1900 ou</code><br><code>[root@rhel ~]# cat /etc/group|grep ou</code><br><code>ou:x:1900:</code><br>//查看文件/etc/group，可以看到组群ou的GID已经更改为1900<br>【例7.23】 修改组群ou的新组群名称为shanghai。<br><code>[root@rhel ~]# groupmod -n shanghai ou</code><br><code>[root@rhel ~]# cat /etc/group|grep shanghai</code><br><code>shanghai:x:1900:</code><br>//查看/etc/group文件，可以通过原来的GID看到组群ou的名称已经更改为shanghai</p><h4 id="删除组群账户"><a href="#删除组群账户" class="headerlink" title="删除组群账户"></a>删除组群账户</h4><p>使用groupdel命令可以在Linux系统中删除 组群账户。如果该组群中仍旧包括某些用 户，那么必须先删除这些用户后，才能删除组群。 </p><p>命令语法：groupdel [组群名]</p><p>【例7.24】 删除组群shanghai。<br><code>[root@rhel ~]# groupdel shanghai</code><br><code>[root@rhel ~]# cat /etc/group|grep shanghai</code><br>//查看/etc/group文件，可以看到当前组群shanghai已经不存在</p><h3 id="用户和组群账户维护"><a href="#用户和组群账户维护" class="headerlink" title="用户和组群账户维护"></a>用户和组群账户维护</h3><p>在日常工作中经常需要对Linux系统用户和组群账户进行维护和管理，主要用到passwd、gpasswd、su、newgrp、groups和id等命令。</p><h4 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h4><p>设置或修改用户的密码，普通用户和超级权限用户都可以运行passwd，普通用户只能更改自己的用户密码，root用户可以设置或修改任何用户的密码。如果passwd命令后面不接任何选项或用户名，则表示修改当前用户的密码。</p><p>命令语法：passwd[选项][用户名]</p><p>【例7.25】 设置用户it的密码。<br><code>[root@rhel ~]# passwd it</code><br>更改用户 it 的密码。<br>新的密码：//在此输入用户it的密码<br>重新输入新的 密码：//在此重复输入用户it的密码<br>passwd：所有的身份验证令牌已经成功更新。</p><p>【例7.26】 锁住用户it的密码。<br><code>[root@rhel ~]# passwd -l it</code><br>锁定用户 it 的密码。<br>passwd: 操作成功<br>//用户it锁住以后不能登录到系统，但是可以用su命令从其他用户切换到用户it<br><code>[root@rhel ~]# passwd -S it</code><br>it LK 2012-06-02 0 99999 7 -1 (密码已被锁定。)<br>//查看用户密码状态，可以看到用户it的密码是锁住的<br><code>[root@rhel ~]# cat /etc/shadow|grep it</code><br>it:!!$6​$/4sUM8yo$pRRuww3238PwFCv2o3T7JWMjAN0FA.zkGzhUBW shHCK0DX2k1udSXa9w8Y.HQ1hjcvG8laKrmFHGjYZfNZmYm1:15493: 0:99999:7:::<br>//查看/etc/shadow文件，可以看到用户it密码锁住以后在密码字段前有“!!”</p><p>【例7.27】 解锁用户it密码。<br><code>[root@rhel ~]# passwd -u it</code><br>解锁用户 it 的密码。<br>passwd: 操作成功<br>//已经成功解锁用户it，重新设置用户密码也可以解锁用户<br><code>[root@rhel ~]# passwd -S it</code><br>it PS 2012-06-02 0 99999 7 -1 (密码已设置，使用 SHA512 算法。)<br>//查看用户密码状态，可以看到用户it的密码已经解锁<br><code>[root@rhel ~]# cat /etc/shadow|grep it</code><br>it:$6​$/4sUM8yo$pRRuww3238PwFCv2o3T7JWMjAN0FA.zkGzhUBW shHCK0DX2k1udSXa9w8Y.HQ1hjcvG8laKrmFHGjYZfNZmYm1:15493 :0:99999:7:::<br>//查看/etc/shadow文件，可以看到用户it密码解锁以后密码字段前的“!!”没有了</p><p>【例7.28】 删除用户it的密码。<br><code>[root@rhel ~]# cat /etc/shadow|grep it</code><br>rtkit:!!:15493:::::: it:$6​$/4sUM8yo$pRRuww3238PwFCv2o3T7JWMjAN0FA.zkGzhUBW shHCK0DX2k1udSXa9w8Y.HQ1hjcvG8laKrmFHGjYZfNZmYm1:15493 :0:99999:7:::<br>//查看/etc/shadow文件，可以看到用户it设置过密码<br><code>[root@rhel ~]# passwd -d it</code><br>清除用户的密码 it。<br>passwd: 操作成功<br><code>[root@rhel ~]# cat /etc/shadow|grep it</code><br>it::15493:0:99999:7:::<br>//查看/etc/shadow文件，可以看到用户it的密码已经没有了</p><h4 id="gpasswd命令"><a href="#gpasswd命令" class="headerlink" title="gpasswd命令"></a>gpasswd命令</h4><p>设置一个组群的组群密码，或者是在组群 中添加、删除用户。 </p><p>命令语法：gpasswd [选项] [组群名]</p><p>【例7.29】 把用户it添加到kk组群中。<br><code>[root@rhel ~]# gpasswd -a it kk</code><br><code>Adding user it to group kk</code><br><code>[root@rhel ~]# cat /etc/group|grep kk</code><br><code>kk:x:1002:it</code><br>//在/etc/group文件中可以看到kk组群中有用户it<br>【例7.30】 从kk组群中删除用户it。<br><code>[root@rhel ~]# gpasswd -d it kk</code><br><code>Removing user it from group kk</code><br><code>[root@rhel ~]# cat /etc/group|grep kk</code><br><code>kk:x:1002:</code><br>//在/etc/group文件中可以看到kk组群中已经没有用户it了</p><p>【例7.a】 设置kk组群的密码。<br><code>[root@rhel ~]# gpasswd kk</code><br>Changing the password for group kk<br>New Password://在此输入组群kk的密码<br>Re-enter new password://在此重复输入组群kk的密码<br>[root@rhel ~]# cat /etc/gshadow|grep kk<br>kk:$6​$LyMEB/59ARw/CdN$Gw8ln2/Vi3vUhzdCvbNInSioUDNcUOWpDu kbMIeuGq8hjWWnVJWaa6BlFzYa6wdvuBkaVK7Cwkbmq0Vd8./0t1:: //在/etc/gshadow文件中可以看到组群kk已经设置密码<br>【例7.b】 取消kk组群密码。<br><code>[root@rhel ~]# gpasswd -r kk</code><br><code>[root@rhel ~]# cat /etc/gshadow|grep kk</code><br>kk:::<br>//在/etc/gshadow文件中可以看到组群kk已经不存在了</p><h4 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h4><p>使用su命令可以切换到其它用户账户进行 登录。如果su命令不加任何选项，默认为 切换到root用户，并且不改变Shell环境。 </p><p>命令语法：su [选项] [用户]</p><p>【例7.31】把用户root切换为用户it进行登录，并且连Shell环境也切换。<br><code>[root@rhel ~]# su - it</code><br>//从用户root切换到普通用户不需要输入用户it的密码<br><code>[it@rhel~] \$pwd</code><br>/home/it<br>//shel环境已经切换，所以当前工作目录路径为/home/it<br>【例7.32】把用户root切换为用户it进行登录，shell环境不需要切。<br><code>[root@rhel~]#su it</code><br><code>[it@rhel root] ​\$ pwd</code><br>/root<br>//shell环境没有切换，所以当前工作目录路径为/root<br>【例7.33】用户it使用su方式以root用户执行“ls /root”命令。<br><code>[it@rhel~]​\$ su - root -c “ls /root”</code><br>密码：<br>//在此输入用户root密码</p><h4 id="newgrp命令"><a href="#newgrp命令" class="headerlink" title="newgrp命令"></a>newgrp命令</h4><p>让用户账户以另一个组群的身份进行登录。 newgrp命令是以相同的账户名，不同的组群身份登录系统。如果要使用newgrp命令切换组群，用户必须是该组群的用户，否则将无法登录指定的 组群。单一用户如果要同时隶属多个组群，需要利用交替用户的设置。如果不指定组群名称，则 newgrp命令会登录该用户名称的预设组群。 </p><p>命令语法：newgrp [组群名]</p><p>【例7.34】将用户ab以组群ou的身份登录系统。<br><code>[ab@rhel root]\$ id</code><br>uid=1008(ab) gid=1005(ab) 组=1005(ab),1006(ou)<br>//当前用户ab分别属于组群ab和ou的成员，是以ab组群的身 份登录系统的<br><code>[ab@rhel root]​\$ newgrp ou</code><br><code>[ab@rhel root]​\$ id</code><br>uid=1008(ab) gid=1006(ou) 组=1006(ab),1005(ou)<br>//现在用户ab是以ou组群的身份登录系统</p><h4 id="groups-命令"><a href="#groups-命令" class="headerlink" title="groups 命令"></a>groups 命令</h4><p>使用groups命令可以显示指定用户账户的 组群成员身份。 </p><p>命令语法：groups [用户名]</p><p>【例7.35】查看用户ab是属于哪些组群的成员。<br><code>[root@rhel ~]# groups ab ab : ab ou</code><br>//可以看到用户ab是属于ab组群和ou组群的用户</p><h4 id="id命令"><a href="#id命令" class="headerlink" title="id命令"></a>id命令</h4><p>使用id命令可以显示用户的UID以及该用户 所属组群的GID。 </p><p>命令语法：id [选项] [用户名]</p><p>【例7.36】 查询用户ab的UID、GID 以及归属组群的情况。<br><code>[root@rhel ～]# id ab</code><br>uid=1008(ab) gid=1005(ab) 组=1005(ab),1006(ou)<br>//用户ab的UID是1008，默认组群是ab，默认用户组群的GID是1005， 归属于ab和ou组群 </p><p>【例7.37】 显示用户ab所属主组群的GID。<br><code>[root@rhel ～]# id -g ab</code><br>1005 //可以看到用户ab所属主组群的GID是1005 </p><p>【例7.38】 显示用户ab所属组群的GID。<br><code>[root@rhel ～]# id -G ab</code><br>1005 1006<br>//可以看到用户ab所属组群的GID是1005和1006 </p><p>【例7.39】显示用户ab的UID。<br><code>[root@rhel ～]# id -u ab</code><br>1008<br>//可以看到用户ab的UID是1008</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Linux系统的组成&quot;&gt;&lt;a href=&quot;#一、Linux系统的组成&quot; class=&quot;headerlink&quot; title=&quot;一、Linux系统的组成&quot;&gt;&lt;/a&gt;一、Linux系统的组成&lt;/h2&gt;&lt;h3 id=&quot;1-内核&quot;&gt;&lt;a href=&quot;#1-内核&quot; cla
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>知识点概览</title>
    <link href="http://yoursite.com/2020/06/20/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2020/06/20/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/</id>
    <published>2020-06-20T12:46:02.000Z</published>
    <updated>2020-06-20T12:54:35.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul><li><p>顺序、选择、循环</p></li><li><p>文件读写</p></li><li><p>String</p></li><li><p>ArrayList</p></li><li><p>数据建模、算法建模</p></li><li><p>递归、高阶函数</p></li><li><p>Register machine</p></li><li><p>Lambda演算</p></li><li><p>程序正确性验证（不考）</p></li><li><p>软件开发生命周期</p></li><li><p>结构化方法和面向对象方法</p></li><li><p>整数、浮点数操作</p></li><li><p>Overriding Vs Overloading</p></li><li><p>封装</p></li><li><p>职责、协作</p></li><li><p>类之间的关系</p></li><li><p>继承</p></li><li><p>多态</p></li><li><p>继承vs组合</p></li><li><p>类的初始化</p></li><li><p>接口</p></li><li><p>针对接口编程</p></li><li><p>可修改性</p></li><li><p>异常</p></li><li><p>GUI控件、布局、事件响应</p></li><li><p>网络、线程、synchronize</p></li><li><p>Java字节码解析</p></li><li><p>Jvm指令的执行</p></li></ul><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li><h4 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h4><ul><li>自顶向下逐步求精</li><li>树状结构</li><li>数据流图</li><li>结构图</li></ul></li><li><h4 id="单个类封装"><a href="#单个类封装" class="headerlink" title="单个类封装"></a>单个类封装</h4><ul><li>数据和行为的在一起</li><li>单一职责</li></ul></li><li><h4 id="多个类封装"><a href="#多个类封装" class="headerlink" title="多个类封装"></a>多个类封装</h4><ul><li>委托</li><li>职责的分配</li></ul></li><li><h4 id="可修改性"><a href="#可修改性" class="headerlink" title="可修改性"></a>可修改性</h4><ul><li>实现的修改（封装）</li><li>扩展（继承，多态）</li><li>灵活性（组合+接口）</li></ul></li></ul><h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><ul><li>lambda演算主要考推演过程</li><li>高阶函数主要考思想，不在乎具体语言</li><li>用例图、数据流图、结构图、类图会考，标准UML</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;知识点：&quot;&gt;&lt;a href=&quot;#知识点：&quot; class=&quot;headerlink&quot; title=&quot;知识点：&quot;&gt;&lt;/a&gt;知识点：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;顺序、选择、循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件读写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strin
      
    
    </summary>
    
    
      <category term="软工一笔记" scheme="http://yoursite.com/categories/%E8%BD%AF%E5%B7%A5%E4%B8%80%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="review" scheme="http://yoursite.com/tags/review/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://yoursite.com/2020/06/14/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/06/14/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-06-14T12:27:07.000Z</published>
    <updated>2020-06-14T12:42:57.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Linux_01.png" alt="img_1"></p><h3 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h3><h4 id="1-用户操作"><a href="#1-用户操作" class="headerlink" title="1. 用户操作"></a>1. 用户操作</h4><p># 表示权限用户(如:root),$ 表示普通用户<br>开机提示:Login:输入用户名<br>password:输入口令 用户是系统注册用户成功登陆后，可以进入相应的用户环境.<br>退出当前shell,输入:exit</p><p>useradd netseek 添加一个netseek用户<br>passwd netseek 给netseek这个用户设置密码.<br>(/etc/passwd /etc/group)<br>userdel netseek 删除账号<br>userdel -r netseek 删除账号连同自家目录</p><h4 id="2-设置linux时间和日期"><a href="#2-设置linux时间和日期" class="headerlink" title="2. 设置linux时间和日期"></a>2. 设置linux时间和日期</h4><p>date 命令(“date MMDDhhmmYYYY.ss”)<br>2006年7月24日12:37 ,30秒<br>date 072412372006.30<br>date -s 20:30:30 #设置系统时间为20: 30:30<br>date -s 2006-7-24 #设置系统时期为2006-7-24<br>clock -r #对系统Bios中读取时间参数<br>clock -w #将系统时间(如由date设置的时间)写入Bios</p><h3 id="二、文件-文件夹操作"><a href="#二、文件-文件夹操作" class="headerlink" title="二、文件/文件夹操作"></a>二、文件/文件夹操作</h3><h4 id="1-查看操作"><a href="#1-查看操作" class="headerlink" title="1. 查看操作"></a>1. 查看操作</h4><p>ls -l 显示文件列表<br>ls -al -a 显示所有档案及目录 (ls内定将档案名或目录名称开头为”.”的视为隐藏档，不会列出)<br>ls -al |grep ‘^d’ 显示目录<br>ls -al |grep ‘^[^d]’ 在一个目录中查询不包含目录的所有文件<br>ls -sh (man ls 查看man帮助.)</p><h4 id="2-linux几种文件类型"><a href="#2-linux几种文件类型" class="headerlink" title="2. linux几种文件类型:"></a>2. linux几种文件类型:</h4><p>d 表示此文件是一个目录<br>- 表示此文件是一个普通文件<br>b 表示此文件是一个特殊的块设备I/O文件<br>c 表示此文件是一个特殊的字符设备I/O文件<br>l 表示此文件是一个连接文件。在其文件名称后紧跟与它连接的文件路径及名称</p><h4 id="3-建立文件和目录"><a href="#3-建立文件和目录" class="headerlink" title="3. 建立文件和目录"></a>3. 建立文件和目录</h4><p>touch 1.txt<br>cat &gt; 2.txt (用定向符创建文件，填写内容后，按ctrl+d保存内容)<br>mkdir mywork 建立mywork这个目录</p><h4 id="4-拷贝文件或目录"><a href="#4-拷贝文件或目录" class="headerlink" title="4. 拷贝文件或目录"></a>4. 拷贝文件或目录</h4><p>cp filename1 filename2<br>cp -r dir1 dir2 复制目录<br>cp -rf 参数f是删除已经存在的目标文件而不提示<br>cp -i 参数i和f相反，在覆盖目标文件之前将给出提示要求用户确认，回答y时目标文件将被覆盖，是交互式拷贝.</p><h4 id="5-删除文件和目录-删除文件或目录都可以用rm搞定"><a href="#5-删除文件和目录-删除文件或目录都可以用rm搞定" class="headerlink" title="5. 删除文件和目录(删除文件或目录都可以用rm搞定)"></a>5. 删除文件和目录(删除文件或目录都可以用rm搞定)</h4><p>rm 1.c //将1.c这个文件删除<br>rm -rf (强制删除文件或目录,删除时不提示.)</p><h4 id="6-移走目录或者改文件名"><a href="#6-移走目录或者改文件名" class="headerlink" title="6. 移走目录或者改文件名"></a>6. 移走目录或者改文件名</h4><p>mv [opitons] 源文件或目录 目标文件或目录<br>[options]主要参数<br>-i:交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答“y”或“n”，<br>这样可以避免误覆盖文件.<br>-f:禁止交互操作。mv操作要覆盖某个已有的目标文件时不给任何指示，指定此参数后i参数将不再起作用。<br>mv hello ../ 将hello目录或者文件移动上一级.</p><h4 id="7-alias-别名"><a href="#7-alias-别名" class="headerlink" title="7. alias 别名"></a>7. alias 别名</h4><p>alias dir=’ls -l’ 输入dir，其实就相当于执行了ls -l</p><h4 id="8-改变当前目录"><a href="#8-改变当前目录" class="headerlink" title="8. 改变当前目录"></a>8. 改变当前目录</h4><p>cd filename 进入 filename 这个目录<br>cd 退出当前目录<br>cd ../ 进入上一级目录.<br>cd - 返回上一次目录<br>cd ~ 返回主目录</p><h4 id="9-cat-more-less-命令"><a href="#9-cat-more-less-命令" class="headerlink" title="9. cat,more,less 命令"></a>9. cat,more,less 命令</h4><p>将某个文件的内容显示出来，<br>三个命令不同的是:cat 把文件内容一直打印出来，而more则分展显示，less 可以上下翻滚查看内容.<br>cat &gt; 1.txt 可以填写或者复制内容,按ctrl+d保存<br>cat 1.c<br>more 1.c<br>head -n filename 显示第N行的内容<br>tail -n filename 显示后N行的内容<br>tail -n /var/log/message 显示最新的20行日志</p><p>未完待续。。。<br><a href="https://zhuanlan.zhihu.com/p/24953800" target="_blank" rel="noopener">参考网址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/Linux_01.png&quot; alt=&quot;img_1&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、基本命令&quot;&gt;&lt;a href=&quot;#一、基本命令&quot; class=&quot;headerlink&quot; title=&quot;一、基本命令&quot;&gt;&lt;/a&gt;一、基本命令&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
    
      <category term="日常学习记录" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>WSL安装</title>
    <link href="http://yoursite.com/2020/06/06/WSL%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/06/06/WSL%E5%AE%89%E8%A3%85/</id>
    <published>2020-06-06T05:57:07.000Z</published>
    <updated>2020-06-14T12:33:10.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、开启WSL"><a href="#一、开启WSL" class="headerlink" title="一、开启WSL"></a>一、开启WSL</h2><p>在 <strong>控制面板</strong>-&gt;<strong>程序</strong>-&gt;<strong>程序和功能</strong> 中点击 <strong>启动或关闭Windows</strong>功能如图</p><p><img src="/images/WSL_01.png" alt="WSL_01"></p><p>勾选 <strong>适用于Linux的Windows子系统</strong></p><p><img src="/images/WSL_02.png" alt="WSL_01"></p><h2 id="二、安装linux"><a href="#二、安装linux" class="headerlink" title="二、安装linux"></a>二、安装linux</h2><h3 id="一、直接安装应用商店的Ubuntu"><a href="#一、直接安装应用商店的Ubuntu" class="headerlink" title="一、直接安装应用商店的Ubuntu"></a>一、直接安装应用商店的Ubuntu</h3><p>在应用商店搜索linux，选择合适的版本下载即可</p><p>（比较简单,不过貌似是只有Ubuntu，而且安装位置不能自己选择）</p><p><img src="/images/WSL_03.png" alt="WSL_02"></p><h3 id="二、使用LxRunOffline安装"><a href="#二、使用LxRunOffline安装" class="headerlink" title="二、使用LxRunOffline安装"></a>二、使用LxRunOffline安装</h3><h4 id="一、下载LXRunOffline"><a href="#一、下载LXRunOffline" class="headerlink" title="一、下载LXRunOffline"></a>一、下载LXRunOffline</h4><p><a href="/download/LxRunOffline-v3.4.0.zip">LxRunOffline-v3.4.0.zip</a></p><p>新建文件夹LXRunOffline，下载减压到该文件夹下</p><p>LXRunOffline的方便之处：</p><ul><li>Install any Linux distro to any directory on your computer.</li><li>Move an existing installation to another directory.</li><li>Duplicate(copy) an existing installation.</li><li>Register an existing installation directory. This enables you to install to a USB stick and use it on different computers.</li><li>Run arbitrary Linux commands in a specified installation.</li><li>Configure default user, environment variables and various flags.</li><li>Export configuration to an XML file and import from the file.</li><li>Export an installation to a tar file.</li></ul><h4 id="二、下载Linux镜像文件"><a href="#二、下载Linux镜像文件" class="headerlink" title="二、下载Linux镜像文件"></a>二、下载Linux镜像文件</h4><p><a href="/download/CentOS7.zip">CentOS7.zip</a></p><p>这个是CentOS7的镜像文件，也可以自己找其他镜像文件</p><h4 id="三、使用LXRunOffline部署Linux到WSL"><a href="#三、使用LXRunOffline部署Linux到WSL" class="headerlink" title="三、使用LXRunOffline部署Linux到WSL"></a>三、使用LXRunOffline部署Linux到WSL</h4><p>使用管理员权限打开cmd，cd到刚刚减压LXRunOffline的文件夹，执行下面的命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LxRunOffline.exe  install -n centos -d E:\ProgramData\Microsoft\Windows\WSL\CentOS -f  E:\Progra</span><br><span class="line">mData\Microsoft\Windows\WSL\centos<span class="number">-7</span>-docker.tar.xz</span><br></pre></td></tr></table></figure><p>其中 -d 后面是要安装到的目录，-f 是前面下载的镜像， -n 用来指定名称。</p><h4 id="四、启动linux"><a href="#四、启动linux" class="headerlink" title="四、启动linux"></a>四、启动linux</h4><p>然后使用  LxRunOffine 来开启 Centos</p><p>执行 <code>LxRunOffline  run  -n centos</code> </p><p>如果想在任何位置使用LXRunOffline，只需要把该文件夹加入环境变量就行。</p><p>参考<a href="https://blog.csdn.net/qq_18286031/article/details/102931794" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、开启WSL&quot;&gt;&lt;a href=&quot;#一、开启WSL&quot; class=&quot;headerlink&quot; title=&quot;一、开启WSL&quot;&gt;&lt;/a&gt;一、开启WSL&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;控制面板&lt;/strong&gt;-&amp;gt;&lt;strong&gt;程序&lt;/strong&gt;-&amp;g
      
    
    </summary>
    
    
      <category term="日常学习记录" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
</feed>
